# Copyright (c) 2015 Hanspeter Portner (dev@open-music-kontrollers.ch)
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the Artistic License 2.0 as published by
# The Perl Foundation.
#
# This source is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# Artistic License 2.0 for more details.
#
# You should have received a copy of the Artistic License 2.0
# along the source as a COPYING file. If not, obtain it from
# http://www.perlfoundation.org/artistic_license_2_0.

@prefix atom:		<http://lv2plug.in/ns/ext/atom#> .
@prefix lv2:		<http://lv2plug.in/ns/lv2core#> .
@prefix pset:		<http://lv2plug.in/ns/ext/presets#> .
@prefix rdf:		<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:		<http://www.w3.org/2000/01/rdf-schema#> .
@prefix state:	<http://lv2plug.in/ns/ext/state#> .
@prefix xsd:		<http://www.w3.org/2001/XMLSchema#> .

@prefix moony:	<http://open-music-kontrollers.ch/lv2/moony#> .

# to please sord_validate
moony:code
	a rdf:Property ;
	rdfs:label "Lua code chunk" .

moony:bank-through_control-through
	state:state [
		moony:code """function run(n, ...)
	return ...
end"""
	] .

moony:bank-through_atom-through
	state:state [
		moony:code """function run(n, seq, forge, ...)
	for frames, atom in seq:foreach() do
		forge:time(frames):atom(atom)
	end

	return ...
end"""
	] .

moony:bank-through_atom-through2
	state:state [
		moony:code """function run(n, seq1, forge1, seq2, forge2)
	for frames, atom in seq1:foreach() do
		forge1:time(frames):atom(atom)
	end

	for frames, atom in seq2:foreach() do
		forge2:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-through_atom-through4
	state:state [
		moony:code """function run(n, seq1, forge1, seq2, forge2, seq3, forge3, seq4, forge4)
	for frames, atom in seq1:foreach() do
		forge1:time(frames):atom(atom)
	end

	for frames, atom in seq2:foreach() do
		forge2:time(frames):atom(atom)
	end

	for frames, atom in seq3:foreach() do
		forge3:time(frames):atom(atom)
	end

	for frames, atom in seq4:foreach() do
		forge4:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-multiplex_atom-multiplex2
	state:state [
		moony:code """function multiplex(seq1, seq2)
  return coroutine.wrap(function()
    local iterator1 = seq1:foreach()
    local iterator2 = seq2:foreach()

    local frames1, atom1 = iterator1(seq1)
    local frames2, atom2 = iterator2(seq2)

    while frames1 or frames2 do
      if frames1 and (frames1 <= frames2) then
        coroutine.yield(frames1, atom1)
        frames1, atom1 = iterator1(seq1)
      else
        coroutine.yield(frames2, atom2)
        frames2, atom2 = iterator2(seq2)
      end
    end
  end)
end

function run(n, seq1, forge1, seq2, forge2)
	for frames, atom in multiplex(seq1, seq2) do
		forge1:time(frames):atom(atom)
		forge2:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-multiplex_atom-multiplex4
	state:state [
		moony:code """function nxt(frames)
	local I = nil
	local F = math.huge

	for i, f in pairs(frames) do
		if f and f < F then
			I, F = i, f
		end
	end

	return I, F
end

seq = {}
itr = {}
frames = {}
atom = {}

function multiplex(...)
	seq[1], seq[2], seq[3], seq[4] = ...

  return coroutine.wrap(function()
		for i, s in ipairs(seq) do
			itr[i] = s:foreach()
			frames[i], atom[i] = itr[i](s)
		end

		local i, f = nxt(frames)
		while i do
			coroutine.yield(f, atom[i])
			frames[i], atom[i] = itr[i](seq[i])
			i, f = nxt(frames)
		end
  end)
end

function run(n, seq1, forge1, seq2, forge2, seq3, forge3, seq4, forge4)
	for frames, atom in multiplex(seq1, seq2, seq3, seq4) do
		forge1:time(frames):atom(atom)
		forge2:time(frames):atom(atom)
		forge3:time(frames):atom(atom)
		forge4:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-midi_midi-responder
	state:state [
		moony:code """midi_responder = MIDIResponder({
	[MIDI.NoteOn] = function(self, frames, forge, chan, note, vel)
		forge:time(frames):midi(MIDI.NoteOn | chan, note, vel)
	end,
	[MIDI.NoteOff] = function(self, frames, forge, chan, note, vel)
		forge:time(frames):midi(MIDI.NoteOff | chan, note, vel)
	end
})

function run(n, seq, forge)
	for frames, atom in seq:foreach() do
		local handled = midi_responder(frames, forge, atom)
	end
end"""
	] .

moony:bank-time_midi-sequencer
	state:state [
		moony:code """time_responder = TimeResponder({
  [Time.speed] = function(self, frames, forge, speed)
    self.rolling = speed > 0.0
    if not self.rolling and forge then
      forge:time(frames):midi(MIDI.Controller, MIDI.AllNotesOff)
    end
  end,
  [Time.barBeat] = function(self, frames, forge, bar_beat)
    if self.rolling and forge then
      forge:time(frames):midi(MIDI.NoteOff, 24, 0x7f)
      forge:time(frames):midi(MIDI.NoteOn, 24, 0x7f)
    end
  end,
  [Time.bar] = function(self, frames, forge, bar)
    if self.rolling and forge then
      forge:time(frames):midi(MIDI.NoteOff, 48, 0x7f)
      forge:time(frames):midi(MIDI.NoteOn, 48, 0x7f)
    end
  end,
  rolling = false
})

function stash(forge)
  time_responder:stash(forge)
end

function apply(atom)
  time_responder:apply(atom)
end

function run(n, seq, forge)
  local from = 0
  for frames, atom in seq:foreach() do
    time_responder(from, frames, forge, atom)
    from = frames
  end
  time_responder(from, n, forge)
end"""
	] .

moony:bank-osc_osc-responder
	state:state [
		moony:code """osc_responder = OSCResponder({
	['/ping'] = function(self, frames, forge, fmt, ...)
		forge:time(frames):message('/pong', fmt, ...)
	end,
	['/pong'] = function(self, frames, forge, fmt, ...)
		forge:time(frames):message('/ping', fmt, ...)
	end
})

function run(n, seq, forge)
  for frames, atom in seq:foreach() do
    local handled = osc_responder(frames, forge, atom)
  end
end"""
	] .

moony:bank-state_state-responder
	state:state [
		<http://open-music-kontrollers.ch/lv2/moony#code> """prefix = 'http://open-music-kontrollers.ch/lv2/moony#a1xa1'
urid = {
  alpha = Map[prefix .. '#alpha'],
  beta = Map[prefix .. '#beta'],
  gamma = Map[prefix .. '#gamma']
}

function alpha_stringify(value)
  return 'alpha = ' .. value .. ' Hz'
end

alpha = {
  [RDFS.label] = 'Alpha',
  [RDFS.comment] = 'This is Alpha',
  [RDFS.range] = Atom.Int,
  [Core.minimum] = 0,
  [Core.maximum] = 10,
  [Units.unit] = Units.hz,
  [RDF.value] = 5,
  [Patch.Set] = function(self, frames, forge, value)
    self[RDF.value] = value
    beta[RDF.value] = alpha_stringify(value)
    if forge then
      forge:time(frames):set(nil, urid.beta):string(beta[RDF.value]):pop()
    end
  end
}

beta = {
  [RDFS.label] = 'Beta',
  [RDFS.comment] = 'This is Beta',
  [RDFS.range] = Atom.String,
  [RDF.value] = alpha_stringify(alpha[RDF.value])
}

gamma = {
  [RDFS.label] = 'Gamma',
  [RDFS.comment] = 'This is Gamma',
  [RDFS.range] = Atom.Double,
  [Core.minimum] = 0.0,
  [Core.maximum] = 2.0,
  [Units.unit] = Units.mm,
  [Core.scalePoint] = {
    zero = 0.0,
    one = 1.0,
    two = 2.0
  },
  [RDF.value] = 1.0
}

state = StateResponder({
  [Patch.writable] = {
    [urid.alpha] = alpha,
    [urid.gamma] = gamma
  },
  [Patch.readable] = {
    [urid.beta] = beta,
  }
})

function save(forge)
  state:stash(forge)
end

function restore(atom)
  state:apply(atom)
  beta[RDF.value] = alpha_stringify(alpha[RDF.value])
end

function run(n, seq, forge, control, notify)
  state:register(0, notify)

  run = function(n, seq, forge, control, notify)
    for frames, atom in control:foreach() do
      state(frames, notify, atom)
    end
  end

  run(n, seq, forge, control, notify)
end"""
	] .
