# Copyright (c) 2015-2016 Hanspeter Portner (dev@open-music-kontrollers.ch)
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the Artistic License 2.0 as published by
# The Perl Foundation.
#
# This source is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# Artistic License 2.0 for more details.
#
# You should have received a copy of the Artistic License 2.0
# along the source as a COPYING file. If not, obtain it from
# http://www.perlfoundation.org/artistic_license_2_0.

@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix atom: <http://lv2plug.in/ns/ext/atom#> .
@prefix lv2: <http://lv2plug.in/ns/lv2core#> .
@prefix pset: <http://lv2plug.in/ns/ext/presets#> .
@prefix midi: <http://lv2plug.in/ns/ext/midi#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix state: <http://lv2plug.in/ns/ext/state#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix moony: <http://open-music-kontrollers.ch/lv2/moony#> .
@prefix lic: <http://opensource.org/licenses/> .
@prefix stateR: <urn:moony:stateR#> .

# to please sord_validate
moony:code
	a rdf:Property ;
	rdfs:label "Lua code chunk" .
moony:state
	a rdf:Property ;
	rdfs:label "Lua code state" .

stateR:pBool
	a lv2:Parameter ;
	rdfs:label "A Bool" ;
	rdfs:range atom:Bool .
stateR:pChunk
	a lv2:Parameter ;
	rdfs:label "A Chunk" ;
	rdfs:range atom:Chunk .
stateR:pEnum
	a lv2:Parameter ;
	rdfs:label "An Enum" ;
	rdfs:range atom:Int .
stateR:pFloat
	a lv2:Parameter ;
	rdfs:label "A Float" ;
	rdfs:range atom:Float .
stateR:pInt
	a lv2:Parameter ;
	rdfs:label "An Int" ;
	rdfs:range atom:Int .
stateR:pPath
	a lv2:Parameter ;
	rdfs:label "A Path" ;
	rdfs:range atom:Path .
stateR:pString
	a lv2:Parameter ;
	rdfs:label "A String" ;
	rdfs:range atom:String .
stateR:pURID
	a lv2:Parameter ;
	rdfs:label "A URID" ;
	rdfs:range atom:URI .

moony:bank-through_control-through
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """function run(n, ...)
	return ...
end"""
	] .

moony:bank-through_atom-through
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """function run(n, seq, forge, ...)
	for frames, atom in seq:foreach() do
		forge:time(frames):atom(atom)
	end

	return ...
end"""
	] .

moony:bank-through_atom-through2
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """function run(n, seq1, forge1, seq2, forge2)
	for frames, atom in seq1:foreach() do
		forge1:time(frames):atom(atom)
	end

	for frames, atom in seq2:foreach() do
		forge2:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-through_atom-through4
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """function run(n, seq1, forge1, seq2, forge2, seq3, forge3, seq4, forge4)
	for frames, atom in seq1:foreach() do
		forge1:time(frames):atom(atom)
	end

	for frames, atom in seq2:foreach() do
		forge2:time(frames):atom(atom)
	end

	for frames, atom in seq3:foreach() do
		forge3:time(frames):atom(atom)
	end

	for frames, atom in seq4:foreach() do
		forge4:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-multiplex_atom-multiplex2
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """function run(n, seq1, forge1, seq2, forge2)
	for frames, atom in seq1:foreach(seq2) do
		forge1:time(frames):atom(atom)
		forge2:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-multiplex_atom-multiplex4
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """function run(n, seq1, forge1, seq2, forge2, seq3, forge3, seq4, forge4)
	for frames, atom in seq1:foreach(seq2, seq3, seq4) do
		forge1:time(frames):atom(atom)
		forge2:time(frames):atom(atom)
		forge3:time(frames):atom(atom)
		forge4:time(frames):atom(atom)
	end
end"""
	] .

moony:bank-midi_midi-responder
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """local midiR = MIDIResponder({
	[MIDI.NoteOn] = function(self, frames, forge, chan, note, vel)
		forge:time(frames):midi(MIDI.NoteOn | chan, note, vel)
	end,
	[MIDI.NoteOff] = function(self, frames, forge, chan, note, vel)
		forge:time(frames):midi(MIDI.NoteOff | chan, note, vel)
	end
})

function run(n, seq, forge)
	for frames, atom in seq:foreach() do
		local handled = midiR(frames, forge, atom)
	end
end"""
	] .

moony:bank-time_midi-sequencer
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """local timeR = TimeResponder({
  [Time.speed] = function(self, frames, forge, speed)
    self.rolling = speed > 0.0
    if not self.rolling and forge then
      forge:time(frames):midi(MIDI.Controller, MIDI.AllNotesOff)
    end
  end,
  [Time.barBeat] = function(self, frames, forge, bar_beat)
    if self.rolling and forge then
      forge:time(frames):midi(MIDI.NoteOff, 24, 0x7f)
      forge:time(frames):midi(MIDI.NoteOn, 24, 0x7f)
    end
  end,
  [Time.bar] = function(self, frames, forge, bar)
    if self.rolling and forge then
      forge:time(frames):midi(MIDI.NoteOff, 48, 0x7f)
      forge:time(frames):midi(MIDI.NoteOn, 48, 0x7f)
    end
  end,
  rolling = false
})

function stash(forge)
  timeR:stash(forge)
end

function apply(atom)
  timeR:apply(atom)
end

function run(n, seq, forge)
  local from = 0
  for frames, atom in seq:foreach() do
    timeR(from, frames, forge, atom)
    from = frames
  end
  timeR(from, n, forge)
end"""
	] .

moony:bank-osc_osc-responder
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """local oscR = OSCResponder({
	['/ping'] = function(self, frames, forge, fmt, ...)
		forge:time(frames):message('/pong', fmt, ...)
	end,
	['/pong'] = function(self, frames, forge, fmt, ...)
		forge:time(frames):message('/ping', fmt, ...)
	end
})

function run(n, seq, forge)
  for frames, atom in seq:foreach() do
    local handled = oscR(frames, forge, atom)
  end
end"""
	] .

moony:bank-state_state-responder
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """local urid = HashMap('urn:moony:stateR#')

local pLong
local pInt = {
  [RDFS.label] = 'Integer',
  [RDFS.comment] = 'This is an Integer',
  [RDFS.range] = Atom.Int,
  [Units.unit] = Units.hz,
  [Core.minimum] = 0,
  [Core.maximum] = 10,
  [RDF.value] = 5,
  [Patch.Set] = function(self, frames, forge, value)
    self[RDF.value] = value
    pLong[RDF.value] = value * 2
    if forge then
      forge:time(frames):set(nil, urid.pLong):long(pLong[RDF.value]):pop()
    end
  end
}

pLong = {
  [RDFS.label] = 'Long',
  [RDFS.comment] = 'This is a Long',
  [RDFS.range] = Atom.Long,
  [Units.unit] = Units.hz,
  [Core.minimum] = pInt[Core.minimum] * 2,
  [Core.maximum] = pInt[Core.maximum] * 2,
  [RDF.value] = pInt[RDF.value] * 2
}

local pDouble
local pFloat = {
  [RDFS.label] = 'Float',
  [RDFS.comment] = 'This is a Float',
  [RDFS.range] = Atom.Float,
  [Units.unit] = Units.m,
  [Core.minimum] = -1.0,
  [Core.maximum] = 1.0,
  [RDF.value] = 0.0,
  [Patch.Set] = function(self, frames, forge, value)
    self[RDF.value] = value
    pDouble[RDF.value] = value * 2
    if forge then
      forge:time(frames):set(nil, urid.pDouble):double(pDouble[RDF.value]):pop()
    end
  end
}

pDouble = {
  [RDFS.label] = 'Double',
  [RDFS.comment] = 'This is a Double',
  [RDFS.range] = Atom.Double,
  [Units.unit] = Units.m,
  [Core.minimum] = pFloat[Core.minimum] * 2,
  [Core.maximum] = pFloat[Core.maximum] * 2,
  [RDF.value] = pFloat[RDF.value] * 2
}

local pBool = {
  [RDFS.label] = 'Bool',
  [RDFS.comment] = 'This is a Boolean',
  [RDFS.range] = Atom.Bool,
  [RDF.value] = true
}

local pURI
local pURID = {
  [RDFS.label] = 'URID',
  [RDFS.comment] = 'This is an URID',
  [RDFS.range] = Atom.URID,
  [RDF.value] = MIDI.MidiEvent,
  [Patch.Set] = function(self, frames, forge, value)
    self[RDF.value] = value
    pURI[RDF.value] = Unmap[value]
    if forge then
      forge:time(frames):set(nil, urid.pURI):uri(pURI[RDF.value]):pop()
    end
  end
}

pURI = {
  [RDFS.label] = 'URI',
  [RDFS.comment] = 'This is an URI',
  [RDFS.range] = Atom.URI,
  [RDF.value] = Unmap(MIDI.MidiEvent)
}

local pString = {
  [RDFS.label] = 'String',
  [RDFS.comment] = 'This is a String',
  [RDFS.range] = Atom.String,
  [RDF.value] = 'hello world'
}

local pChunk = {
  [RDFS.label] = 'Chunk',
  [RDFS.comment] = 'This is a Chunk',
  [RDFS.range] = Atom.Chunk,
  [RDF.value] = string.char(0x1, 0x2, 0x3),
  [Patch.Set] = function(self, frames, forge, value)
    self[RDF.value] = value
    for i = 1, #value do
      print(i, string.byte(value, i))
    end
  end
}

local pPath = {
  [RDFS.label] = 'Path',
  [RDFS.comment] = 'This is a Path',
  [RDFS.range] = Atom.Path,
  [RDF.value] = '/tmp/file.suffix'
}

local pEnum = {
  [RDFS.label] = 'Enum',
  [RDFS.comment] = 'This is an Enum',
  [RDFS.range] = Atom.Int,
  [RDF.value] = 0,
  [Core.minimum] = 0,
  [Core.maximum] = 2,
  [Core.scalePoint] = {
    zero = 0,
    one = 1,
    two = 2
  }
}

local stateR = StateResponder({
  [Patch.writable] = {
    [urid.pInt] = pInt,
    [urid.pFloat] = pFloat,
    [urid.pBool] = pBool,
    [urid.pURID] = pURID,
    [urid.pString] = pString,
    [urid.pChunk] = pChunk,
    [urid.pPath] = pPath,
    [urid.pEnum] = pEnum
  },
  [Patch.readable] = {
    [urid.pLong] = pLong,
    [urid.pDouble] = pDouble,
    [urid.pURI] = pURI
  }
})

function save(forge)
  stateR:stash(forge)
end

function restore(atom)
  stateR:apply(atom)
  pLong[RDF.value] = pInt[RDF.value] * 2
  pDouble[RDF.value] = pFloat[RDF.value] * 2
  pURI[RDF.value] = Unmap[pURID[RDF.value]]
end

function once(n, seq, forge, control, notify)
  stateR:register(0, notify)
end

function run(n, seq, forge, control, notify)
  for frames, atom in control:foreach() do
    stateR(frames, notify, atom)
  end
end""" ;
		moony:state [
			stateR:pBool true ;
			stateR:pChunk "AQIDBAUGBw=="^^xsd:base64Binary ;
			stateR:pEnum 0 ;
			stateR:pFloat "8e-1"^^xsd:float ;
			stateR:pInt 9 ;
			stateR:pPath <file:///tmp/file.suffix> ;
			stateR:pString "world hello" ;
			stateR:pURID <http://lv2plug.in/ns/ext/midi#MidiEvent>
		]
	] .

moony:bank-tutorial_part-1
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """-- Tutorial 1: MIDI Channel Blocker

-- define table which holds active MIDI channels
local channels = {0, 2, 4, 6}

-- derive channel mask based on active channels
local mask = 0 -- block everything
for i, v in ipairs(channels) do
	mask = mask | (1 << v) -- toggle bit of active channel
end

function run(n, seq, forge, control, notify) 
	for frames, atom in seq:foreach() do -- iterate over incoming events
		local block = false -- assume a not-to-be-blocked event by default

		if atom.type == MIDI.MidiEvent then -- check for MIDI message
			local msg = atom[1] -- get first MIDI byte
			local cmd = msg & 0xf0 -- get MIDI command nibble
			local chn = msg & 0x0f -- get MIDI channel nibble

			if (cmd ~= 0xf0) and ((1 << chn) & mask == 0) then
				block = true -- if not a system message and channel not part of mask
			end
		end

		if not block then -- let atom through
			forge:time(frames):atom(atom) -- serialize atom as-is
		end
	end
end"""
	] .

moony:bank-tutorial_part-2
	a pset:Preset ;
	doap:license lic:Artistic-2.0 ;
	state:state [
		moony:code """-- Tutorial 2: MIDI Chorder

-- define table that holds number of chord notes and their offsets
local chord = {0, 12, 24, 36} -- octaves, obviously

-- define a general note responder factory
local function noteResponder(cmd)
	return function (self, frames, forge, chan, note, vel)
		for i, v in ipairs(chord) do -- iterate over chord offsets
			local chanNew = i - 1 -- set MIDI channel to chord index - 1
			local noteNew = note + v -- set MIDI note to chord offset
			if noteNew >= 0 and noteNew <= 0x7f then -- handle note under/overflows
				forge:time(frames):midi(cmd | chanNew, noteNew, vel) -- serialize event
			end
		end
	end
end

-- define a MIDIResponder object configured to pass-through unmatched messages
local midiR = MIDIResponder({
	[MIDI.NoteOn] = noteResponder(MIDI.NoteOn), -- create responder for NoteOn
	[MIDI.NoteOff] = noteResponder(MIDI.NoteOff), -- and NoteOff
	[MIDI.NotePressure] = noteResponder(MIDI.NotePressure) -- and NotePressure
}, true)

function run(n, seq, forge, control, notify) 
	for frames, atom in seq:foreach() do -- iterate over incoming events
		local handled = midiR(frames, forge, atom) -- call responder for event
	end
end"""
	] .
