<!DOCTYPE html>
<html>

<head>
	<title>Moony Manual</title>
	<meta name="author" content="Hanspeter Portner" />
	<meta charset="UTF-8" />
	<link rel="icon" type="image/png" href="favicon.png" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<script type="text/javascript" src="jquery-3.1.0.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="ace.js" charset="utf-8"></script>
</head>

<body>

<div class="api-menu">
	<h1>moony - manual</h1>
	<h4>v@MOONY_VERSION@</h4>

	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>

		<li><a href="#variants">Plugin Variants</a>
			<ul>
				<li><a href="#variants-c1xc1">C1 x C1</a></li>
				<li><a href="#variants-c2xc2">C2 x C2</a></li>
				<li><a href="#variants-c4xc4">C4 x C4</a></li>
				<li><a href="#variants-a1xa1">A1 x A1</a></li>
				<li><a href="#variants-a2xa2">A2 x A2</a></li>
				<li><a href="#variants-a4xa4">A4 x A4</a></li>
				<li><a href="#variants-c1a1xc1a1">C1+A1 x C1+A1</a></li>
				<li><a href="#variants-c2a1xc2a1">C2+A1 x C2+A1</a></li>
				<li><a href="#variants-c4a1xc4a1">C4+A1 x C4+A1</a></li>
			</ul>
		</li>

		<li><a href="#log-and-debug">Log &amp; Debug</a>
		</li>

		<li><a href="#callbacks">Callbacks</a>
			<ul>
				<li><a href="#callbacks-run">run</a></li>
				<li><a href="#callbacks-once">once</a></li>
				<li><a href="#callbacks-stash">stash</a></li>
				<li><a href="#callbacks-apply">apply</a></li>
				<li><a href="#callbacks-save">save</a></li>
				<li><a href="#callbacks-restore">restore</a></li>
			</ul>
		</li>

		<li><a href="#urid">Map &amp; Unmap</a>
			<ul>
				<li><a href="#urid-map">Map</a></li>
				<li><a href="#urid-unmap">Unmap</a></li>
				<li><a href="#urid-hashmap">HashMap</a></li>
				<li><a href="#urid-voicemap">VoiceMap</a></li>
			</ul>
		</li>

		<li><a href="#forge">Forge</a>
			<ul>
				<li><a href="#forge-primitive">Primitive</a>
					<ul>
						<li><a href="#forge-bool">Bool</a></li>
						<li><a href="#forge-int">Int</a></li>
						<li><a href="#forge-long">Long</a></li>
						<li><a href="#forge-float">Float</a></li>
						<li><a href="#forge-double">Double</a></li>
						<li><a href="#forge-urid">URID</a></li>
						<li><a href="#forge-uri">URI</a></li>
						<li><a href="#forge-string">String</a></li>
						<li><a href="#forge-path">Path</a></li>
						<li><a href="#forge-literal">Literal</a></li>
						<li><a href="#forge-chunk">Chunk</a></li>
						<li><a href="#forge-midi">MIDI</a></li>
						<li><a href="#forge-raw">Raw</a></li>
						<li><a href="#forge-typed">Typed</a></li>
						<li><a href="#forge-atom">Atom</a></li>
					</ul>
				</li>
				<li><a href="#forge-container">Container</a>
					<ul>
						<li><a href="#forge-sequence">Sequence</a>
							<ul>
								<li><a href="#forge-frame-time">Frame Time</a></li>
								<li><a href="#forge-beat-time">Beat Time</a></li>
								<li><a href="#forge-time">Time</a></li>
							</ul>
						</li>
						<li><a href="#forge-object">Object</a>
							<ul>
								<li><a href="#forge-key">Key</a></li>
							</ul>
						</li>
						<li><a href="#forge-tuple">Tuple</a></li>
						<li><a href="#forge-vector">Vector</a></li>
						<li><a href="#forge-pop">Pop</a></li>
					</ul>
				</li>
				<li><a href="#forge-osc">OSC</a>
					<ul>
						<li><a href="#forge-bundle">Bundle</a></li>
						<li><a href="#forge-message">Message</a></li>
					</ul>
				</li>
				<li><a href="#forge-patch-patch">Patch</a>
					<ul>
						<li><a href="#forge-patch">Patch</a></li>
						<ul>
							<li><a href="#forge-add">Add</a></li>
							<li><a href="#forge-remove">Remove</a></li>
						</ul>
						<li><a href="#forge-get">Get</a></li>
						<li><a href="#forge-set">Set</a></li>
						<li><a href="#forge-put">Put</a></li>
						<li><a href="#forge-ack">Ack</a></li>
						<li><a href="#forge-error">Error</a></li>
					</ul>
				</li>
			</ul>
		</li>

		<li><a href="#atom">Atom</a>
			<ul>
				<li><a href="#atom-primitive">Primitive</a>
					<ul>
						<li><a href="#atom-nil">Nil</a></li>
						<li><a href="#atom-bool">Bool</a></li>
						<li><a href="#atom-int">Int</a></li>
						<li><a href="#atom-long">Long</a></li>
						<li><a href="#atom-float">Float</a></li>
						<li><a href="#atom-double">Double</a></li>
						<li><a href="#atom-urid">URID</a></li>
						<li><a href="#atom-uri">URI</a></li>
						<li><a href="#atom-string">String</a></li>
						<li><a href="#atom-path">Path</a></li>
						<li><a href="#atom-literal">Literal</a></li>
						<li><a href="#atom-chunk">Chunk</a></li>
						<li><a href="#atom-midi">MIDI</a></li>
					</ul>
				</li>
				<li><a href="#atom-container">Container</a>
					<ul>
						<li><a href="#atom-sequence">Sequence</a></li>
						<li><a href="#atom-tuple">Tuple</a></li>
						<li><a href="#atom-object">Object</a></li>
						<li><a href="#atom-vector">Vector</a></li>
					</ul>
				</li>
			</ul>
		</li>

		<li><a href="#stash">Stash</a></li>

		<li><a href="#responder">Responder</a>
			<ul>
				<li><a href="#responder-midi">MIDIResponder</a></li>
				<li><a href="#responder-osc">OSCResponder</a></li>
				<li><a href="#responder-time">TimeResponder</a></li>
				<li><a href="#responder-state">StateResponder</a></li>
			</ul>
		</li>

		<li><a href="#util">Utilities</a>
			<ul>
				<li><a href="#util-midi2cps">midi2cps</a></li>
				<li><a href="#util-cps2midi">cps2midi</a></li>
				<li><a href="#util-encrypt">Encrypt</a></li>
				<li><a href="#util-decrypt">Decrypt</a></li>
			</ul>
		</li>

		<li><a href="#license">License</a>
		</li>
	</ul>
</div>

<div class="api-body">

	<div class="api-section"><div class="api-content">
	<h1 id="introduction">Introduction</h1>
		<p>The design goal of the plugin bundle was to create a tool to easily add realtime programmable logic glue in LV2 plugin graphs.</p>

		<p>To have plugins which do a specific task efficiently is great, especially for audio plugins. LV2 stands apart from other audio plugin specifications with its extentable event system based on Atoms. As events can be much more varied in nature and represent pretty much anything (NOT ONLY MIDI), it would be useful to have a tool to create arbitrary event filters for a given setup on-the-fly.</p>

		<p>For a given setup, one may need a special event filter only once and it seems to be overkill to write a native LV2 event filter in C/C++ just for that. It would also be nice to have a tool for fast prototyping of new event filters.</p>

		<p>A scripting language seems to be ideal for these cases, where the user can write an event filter on a higher level of abstraction on-the-fly. The scripting language needs to be realtime safe, though, which restricts the choices dramatically.</p>

		<p>One such scripting language is Lua. It is small, fast, easily embeddable and realtime-safe if coupled to a realtime-safe memory allocator like TLSF.</p>

		<p>The Moony plugins can handle LV2 control and atom event ports, only. They do not handle LV2 audio ports. They may eventually handle LV2 control-voltage ports in the future, though. Control port values are internally handled as simple floating point numbers, whereas the atom event ports build on top of the LV2 atom and atom forge C headers.</p>
	</div></div>

	<div class="api-section"><div class="api-content">
	<h1 id="variants">Plugin Variants</h1>
		<p>The Moony plugin bundle ships with multiple plugin variants, whereas all of them share the same
			API but with different configurations of input and output ports. Depending on the users's usage
			scenario, one or the other variant may be preferable.</p>
		<p>Plugin variants only differ in number of control and atom event input and output ports. Apart
			from this difference, they can often be used interchangeably.</p>
	</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-c1xc1">C1 x C1</h2>
		<p>This plugin variant features a single control port input and a single control port output.</p>

		<a class="api-snippet" href="#snippet-run-c1xc1" data-snippet="snippet-run-c1xc1">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-c1xc1">-- C1 x C1 prototype 'run' function

function run(n, c, control, notify)
	return c
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-c2xc2">C2 x C2</h2>
		<p>This plugin variant features two control port inputs and two control port outputs.</p>

		<a class="api-snippet" href="#snippet-run-c2xc2" data-snippet="snippet-run-c2xc2">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-c2xc2">-- C2 x C2 prototype 'run' function

function run(n, c1, c2, control, notify)
	return c1, c2
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-c4xc4">C4 x C4</h2>
		<p>This plugin variant features four control port inputs and four control port outputs.</p>

		<a class="api-snippet" href="#snippet-run-c4xc4" data-snippet="snippet-run-c4xc4">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-c4xc4">-- C4 x C4 prototype 'run' function

function run(n, c1, c2, c3, c4, control, notify)
	return c1, c2, c3, c4
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-a1xa1">A1 x A1</h2>
		<p>This plugin variant features a single atom port input and a single atom port output.</p>

		<a class="api-snippet" href="#snippet-run-a1xa1" data-snippet="snippet-run-a1xa1">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-a1xa1">-- A1 x A1 prototype 'run' function

function run(n, seq, forge, control, notify)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-a2xa2">A2 x A2</h2>
		<p>This plugin variant features two atom port inputs and two atom port outputs.</p>

		<a class="api-snippet" href="#snippet-run-a2xa2" data-snippet="snippet-run-a2xa2">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-a2xa2">-- A2 x A2 prototype 'run' function

function run(n, seq1, forge1, seq2, forge2, control, notify)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-a4xa4">A4 x A4</h2>
		<p>This plugin variant features four atom port inputs and four atom port outputs.</p>

		<a class="api-snippet" href="#snippet-run-a4xa4" data-snippet="snippet-run-a4xa4">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-a4xa4">-- A4 x A4 prototype 'run' function

function run(n, seq1, forge1, seq2, forge2, seq3, forge3, seq4, forge4, control, notify)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-c1a1xc1a1">C1+A1 x C1+A1</h2>
		<p>This plugin variant features a single control port input and a single control port output
			with a single atom port input and a single atom port output.</p>

		<a class="api-snippet" href="#snippet-run-c1a1xc1a1" data-snippet="snippet-run-c1a1xc1a1">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-c1a1xc1a1">-- C1+A1 x C1+A1 prototype 'run' function

function run(n, seq, forge, c, control, notify)
	return c
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-c2a1xc2a1">C2+A1 x C2+A1</h2>
		<p>This plugin variant features two control port inputs and two control port outputs
			with a single atom port input and a single atom port output.</p>

		<a class="api-snippet" href="#snippet-run-c2a1xc2a1" data-snippet="snippet-run-c2a1xc2a1">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-c2a1xc2a1">-- C2+A1 x C2+A1 prototype 'run' function

function run(n, seq, forge, c1, c2, control, notify)
	return c1, c2
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="variants-c4a1xc4a1">C4+A1 x C4+A1</h2>
		<p>This plugin variant features four control port inputs and four control port outputs
			with a single atom port input and a single atom port output.</p>

		<a class="api-snippet" href="#snippet-run-c4a1xc4a1" data-snippet="snippet-run-c4a1xc4a1">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-run-c4a1xc4a1">-- C4+A1 x C4+A1 prototype 'run' function

function run(n, seq, forge, c1, c2, c3, c4, control, notify)
	return c1, c2, c3, c4
end</code></pre>
		</div></div>

	<div class="api-section"><div class="api-content">
	<h1 id="log-and-debug">Log &amp; Debug</h1>
		<p>Whenever you want to log or debug something while developing your scripts, you can easily dump any value via Lua's <b>print</b> function. The print's output will be shown on the UI and also be sent to the host's log backend, e.g. to a log window or console.</p>

	<a class="api-snippet" href="#snippet-print" data-snippet="snippet-print">&rArr; show snippet</a>
	<pre class="api-hidden"><code id="snippet-print">-- sends 'hello world' to the UI and the host's log backend

print('hello world')</code></pre>
	</div></div>

	<div class="api-section"><div class="api-content">
	<h1 id="callbacks">Callbacks</h1>
	<p>Moony can run user defined callbacks at different positions in its
	processing graph. If the user provides an implementation for a specific
	callback, Moony will run the latter. If the plugin does not need a specific
	callback, the latter can simply be omitted. The implementations of all
	callbacks are thus optional.</p>
	</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="callbacks-run">run</h2>
		<p>The <b>run</b> callback function is the main callback function and thus the most
		important one. It is called once per period by the plugin host. The period size,
		e.g. the number of audio samples the function is called for may be chosen
		arbitrary by the host. Do not expect it to be constant.</p>

		<p>Depending on the plugin variant, the <b>run</b> function takes variable amount
		of arguments. All variants have the first and last two arguments in common, though.</p>
		
		<p>If a plugin has input event ports, sequence objects (Lua userdata) will be
		given to the <b>run</b> function whose events can be iterated over.</p>

		<p>If a plugin has output event ports, forge objects (Lua userdata) will be
		given to the <b>run</b> function which can be filled with arbitrary atom event
		structures.</p>

		<p>If a plugin has input control ports, those values will be given to the <b>run</b>
		function as native Lua numbers.</p>

		<p>If a plugin has output control ports, the <b>run</b> function is expected to 
		return native Lua numbers, missing return values will be set to 0.0.</p>

		<dl>
			<dt class="func">function run(n, seq1, forge1, ..., c1, ..., control, notify)</dt>
			<dt>n (integer)</dt>
				<dd>number of audio samples of current period</dd>
			<dt>{seq, forge} [x] (userdata, userdata)</dt>
				<dd>pairs of atom sequence and atom forge objects, with x=[0, 1, 2, 4]</dd>
			<dt>c [x] (number)</dt>
				<dd>control port inputs, with x=[0, 1, 2, 4]</dd>
			<dt>{control, notify} (userdata, userdata)</dt>
				<dd>pair of atom sequence and atom forge object for communication with UI</dd>
			<dt class="ret">(number)</dt>
				<dd>control port outputs, with x=[0, 1, 2, 4]</dd>
		</dl>

		<a class="api-snippet" href="#snippet-callback-run" data-snippet="snippet-callback-run">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-callback-run">-- 'run' callback prototype for moony#a1xa1

function run(n, seq, forge, control, notify)
	-- here we will process events
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="callbacks-once">once</h2>
		<p>The <b>once</b> function exists for pure convenience only. It has exactly the
		same form as the <b>run</b> function, but is called only once after the whole
		script code is loaded or updated.</p>

		<p>The <b>once</b> function will run directly before the <b>run</b> function,
		it therefore is no replacement for the latter in a given update period, but
		and extension to it.</p>

		<p>Put logic here that needs to run once after script code update, e.g. registering
		a new <a href="#state-responder">StateResponder</a>.</p>

		<dl>
			<dt class="func">function once(n, seq1, forge1, ..., c1, ..., control, notify)</dt>
			<dt>n (integer)</dt>
				<dd>number of audio samples of current period</dd>
			<dt>{seq, forge} [x] (userdata, userdata)</dt>
				<dd>pairs of atom sequence and atom forge objects, with x=[0, 1, 2, 4]</dd>
			<dt>c [x] (number)</dt>
				<dd>control port inputs, with x=[0, 1, 2, 4]</dd>
			<dt>{control, notify} (userdata, userdata)</dt>
				<dd>pair of atom sequence and atom forge object for communication with UI</dd>
		</dl>

		<a class="api-snippet" href="#snippet-callback-once" data-snippet="snippet-callback-once">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-callback-once">-- 'once' callback prototype for moony#a1xa1

local stateR = StateResponder({})

function once(n, seq, forge, control, notify)
	-- here we will run logic once right after a code update

	-- register state parameters with the plugin's UI
	stateR:register(0, notify)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="callbacks-stash">stash</h2>
		<p>When script code is reloaded, plugin state inside Lua virtual machine
		potentially is lost. In order to preserve state across a script code reload,
		arbitrary state can be serialized and parked in temporary memory.
		Such a temporary serialized state can later be deserialized via
		<a href="#callbacks-apply">apply</a>.</p>

		<p>The <b>stash</b> function is directly called before parsing and loading
		the new script code.</p>

		<dl>
			<dt class="func">function stash(forge)</dt>
			<dt>forge (userdata)</dt>
				<dd>atom forge object to serialize to</dd>
		</dl>

		<a class="api-snippet" href="#snippet-callback-stash" data-snippet="snippet-callback-stash">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-callback-stash">-- 'stash' callback prototype for moony#a1xa1

local timeR = TimeResponder({})

function stash(forge)
	-- here we can serialize arbitrary data to an atom forge object

	timeR:stash(forge)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="callbacks-apply">apply</h2>
		<p>When script code is reloaded, plugin state inside Lua virtual machine
		potentially is lost. In order to preserve state across a script code reload,
		arbitrary state previously serialized by <a href="#callbacks-stash">stash</a>
		can be deserialized from temporary memory.</p>

		<p>The <b>apply</b> function is directly called after parsing and loading
		the new script code.</p>

		<dl>
			<dt class="func">function apply(atom)</dt>
			<dt>atom (userdata)</dt>
				<dd>atom object to deserialize from</dd>
		</dl>

		<a class="api-snippet" href="#snippet-callback-apply" data-snippet="snippet-callback-apply">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-callback-apply">-- 'apply' callback prototype for moony#a1xa1

local timeR = TimeResponder({})

function apply(atom)
	-- here we can deserialize arbitrary data to an atom forge object

	timeR:apply(timeR)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="callbacks-save">save</h2>
		<p>The <b>save</b> function works analogously to <a href="#callbacks-stash">stash</a>,
		but instead of serializing to temporary memory before a script code reload,
		<b>save</b> serializes to disk upon a state save request issued by the host.</p>

		<p>State serialized to disk by <b>save</b> is preserved across plugin instantiations
		and truly is the same as a preset.</p>

		<dl>
			<dt class="func">function save(forge)</dt>
			<dt>forge (userdata)</dt>
				<dd>atom forge object to serialize to</dd>
		</dl>

		<a class="api-snippet" href="#snippet-callback-save" data-snippet="snippet-callback-save">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-callback-save">-- 'save' callback prototype for moony#a1xa1

local stateR = StateResponder({})

function save(forge)
	-- here we can serialize arbitrary data to an atom forge object

	stateR:stash(forge)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="callbacks-restore">restore</h2>
		<p>The <b>restore</b> function works analogously to <a href="#callbacks-apply">apply</a>,
		but instead of deserializing from temporary memory after a script code reload,
		<b>restore</b> deserializes from disk upon a state reload request issued by the host.</p>

		<dl>
			<dt class="func">function restore(atom)</dt>
			<dt>atom (userdata)</dt>
				<dd>atom object to deserialize from</dd>
		</dl>

		<a class="api-snippet" href="#snippet-callback-restore" data-snippet="snippet-callback-restore">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-callback-restore">-- 'restore' callback prototype for moony#a1xa1

local stateR = StateResponder({})

function restore(atom)
	-- here we can deserialize arbitrary data to an atom forge object

	stateR:apply(atom)
end</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h1 id="urid">Map &amp; Unmap</h1>
		<p>LV2 references objects and their properties by URIs, usually rather long,
		unique string identifiers. When comparing URIs, whole strings need to be
		compared, which is inefficient. In LV2, an URI thus can be mapped to a simple
		integer URID, greatly increasing efficiency of comparisons. Unmapping from
		URID to original URI is supported, too.</p>

		<p>Moony directly mirrors mapping and unmapping of the underlying low-level
		implementation, but additionally caches every newly queried URI or URID
		for faster lookup inside script code. Cached URIs and URIDs are preserved
		across script code updates.</p>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="urid-map">Map</h2>
		<p>Map an URI to its corresponding URID. <b>Map</b> is a first-class Lua
		table acting as a cache for all queried URIDs and can also be called as
		function.</p>

		<dl>
			<dt class="func">function Map(URI)</dt>
			<dt>URI (string)</dt>
				<dd>URI to be mapped</dd>
			<dt class="ret">(integer)</dt>
				<dd>mapped URID</dd>
		</dl>

		<a class="api-snippet" href="#snippet-map" data-snippet="snippet-map">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-map">-- Map can be indexed or called as function

local prefix = 'http://example.com#'

local foo_urid = Map(prefix .. 'foo')
local bar_urid = Map[prefix .. 'bar']</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="urid-unmap">Unmap</h2>
		<p>Unmap an URID to its original URI. <b>Unmap</b> is a first-class Lua
		table acting as a cache for all queried URIs and can also be called as
		function.</p>

		<dl>
			<dt class="func">function Unmap(URID)</dt>
			<dt>URID (integer)</dt>
				<dd>URID to be unmapped</dd>
			<dt class="ret">(string)</dt>
				<dd>unmapped URi</dd>
		</dl>

		<a class="api-snippet" href="#snippet-unmap" data-snippet="snippet-unmap">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-unmap">-- Unmap can be indexed or called as function

local prefix = 'http://example.com#'

local foo_urid= Map(prefix .. 'foo')
local bar_urid = Map[prefix .. 'bar']

local foo_uri = Unmap(foo_urid)
local bar_uri = Unmap[bar_urid]

assert(prefix .. 'foo' == foo_uri)
assert(prefix .. 'bar' == bar_uri)</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="urid-hashmap">HashMap</h2>
		<p>A convenience wrapper and syntactic sugar around <a href="#urid-map">Map</a>.
		Simplifies creating multiple mappings which share a common URI prefix.</p>
		
		<p>Returns a table which can be queried by indexing with the URI postfix.
		The query is equivalent to a mapping of concatenated URI prefix and postfix.</p>

		<p>This is especially useful when dealing with custom properties and the
		<a href="#responder-state">StateResponder</a>.</p>

		<dl>
			<dt class="func">function HashMap(prefix)</dt>
			<dt>prefix (string)</dt>
				<dd>prefix string to be appended to</dd>
			<dt class="ret">(table)</dt>
				<dd>HashMap table</dd>
		</dl>

		<a class="api-snippet" href="#snippet-hashmap" data-snippet="snippet-hashmap">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-hashmap">-- HashMap is a convenience wrapper over Map

local prefix = 'http://example.com#'
local hashmap = HashMap(prefix)

local bar_urid = Map[prefix .. 'bar']

assert(hashmap.bar == bar_urid)</code></pre>
		</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="urid-voicemap">VoiceMap</h2>
		<p>Returns a unique, non-colliding integer ID to be used in event messaging.
		Especially useful for <a href="#forge-patch">Patch</a> messages or custom
		event systems where there is a need to track event properties over space
		and time.</p>

		<dl>
			<dt class="func">function VoiceMap()</dt>
			<dt class="ret">(integer)</dt>
				<dd>unique integer ID</dd>
		</dl>

		<a class="api-snippet" href="#snippet-voicemap" data-snippet="snippet-voicemap">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-voicemap">-- VoiceMap returns unique integer IDs

local cache = {}

for i = 1, 100 do
	local id = VoiceMap()

	assert(not cache[id])
	cache[id] = true
end</code></pre>
		</div></div>

	<!-- Forge -->
	<div class="api-section"><div class="api-content">
	<h1 id="forge">Forge</h1>
	<p>A forge object is used to serialize arbitrary complex atoms, both simple
	primitives and nested containers.</p>
	</div></div>

		<!-- Forge Primitive -->
		<div class="api-section"><div class="api-content">
		<h2 id="forge-primitive">Primitive</h2>
		<p>Atom types that contain single data as part of their body are referred to
		as primitives.</p>
		</div></div>

			<!-- Forge Bool -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-bool">Bool</h3>
			<p>Forge a boolean atom, e.g. of type Atom.Bool.</p>

			<dl>
				<dt class="func">forge:bool(value)</dt>
				<dt>value (boolean)</dt>
					<dd>boolean value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-bool" data-snippet="snippet-forge-bool">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-bool">-- Forge Bool

-- serialize
local io = Stash()

io:bool(true)
io:bool(false)</code></pre>
			</div></div>

			<!-- Forge Int -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-int">Int</h3>
			<p>Forge an integer atom, e.g. of type Atom.Int.</p>

			<dl>
				<dt class="func">forge:int(value)</dt>
				<dt>value (integer)</dt>
					<dd>integer value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-int" data-snippet="snippet-forge-int">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-int">-- Forge Int

-- serialize
local io = Stash()

io:int(12)</code></pre>
			</div></div>

			<!-- Forge Long -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-long">Long</h3>
			<p>Forge long integer atom, e.g. of type Atom.Long.</p>

			<dl>
				<dt class="func">forge:long(value)</dt>
				<dt>value (integer)</dt>
					<dd>integer value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-long" data-snippet="snippet-forge-long">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-long">-- Forge Long

-- serialize
local io = Stash()

io:long(12)</code></pre>
			</div></div>

			<!-- Forge Float -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-float">Float</h3>
			<p>Forge single-precision float atom, e.g. of type Atom.Float.</p>

			<dl>
				<dt class="func">forge:float(value)</dt>
				<dt>value (number)</dt>
					<dd>number value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-float" data-snippet="snippet-forge-float">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-float">-- Forge Float

-- serialize
local io = Stash()

io:float(12.5)</code></pre>
			</div></div>

			<!-- Forge Double -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-double">Double</h3>
			<p>Forge double-precision float atom, e.g. of type Atom.Double.</p>

			<dl>
				<dt class="func">forge:double(value)</dt>
				<dt>value (number)</dt>
					<dd>number value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-double" data-snippet="snippet-forge-double">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-double">-- Forge Double 

-- serialize
local io = Stash()

io:double(12.5)</code></pre>
			</div></div>

			<!-- Forge URID -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-urid">URID</h3>
			<p>Forge URID atom, e.g. of type Atom.URID.</p>

			<dl>
				<dt class="func">forge:urid(value)</dt>
				<dt>value (integer)</dt>
					<dd>URID value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-urid" data-snippet="snippet-forge-urid">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-urid">-- Forge URID

local uri = 'urn:moony:xzy'
local urn = Map[uri]

-- serialize
local io = Stash()

io:urid(urn)</code></pre>
			</div></div>

			<!-- Forge URI -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-uri">URI</h3>
			<p>Forge URI atom, e.g. of type Atom.URI.</p>

			<dl>
				<dt class="func">forge:uri(value)</dt>
				<dt>value (string)</dt>
					<dd>URI value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-uri" data-snippet="snippet-forge-uri">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-uri">-- Forge URI

local uri = 'urn:moony:xzy'

-- serialize
local io = Stash()

io:uri(uri)</code></pre>
			</div></div>

			<!-- Forge String -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-string">String</h3>
			<p>Forge string atom, e.g. of type Atom.String.</p>

			<dl>
				<dt class="func">forge:string(value)</dt>
				<dt>value (string)</dt>
					<dd>string value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-string" data-snippet="snippet-forge-string">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-string">-- Forge String

-- serialize
local io = Stash()

io:string('hello world')</code></pre>
			</div></div>

			<!-- Forge Path -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-path">Path</h3>
			<p>Forge path atom, e.g. of type Atom.Path.</p>

			<dl>
				<dt class="func">forge:path(value)</dt>
				<dt>value (string)</dt>
					<dd>string value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-path" data-snippet="snippet-forge-path">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-path">-- Forge Path

-- serialize
local io = Stash()

io:path('/tmp/xyz')</code></pre>
			</div></div>

			<!-- Forge Literal -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-literal">Literal</h3>
			<p>Forge literal atom, e.g. of type Atom.Literal.</p>

			<dl>
				<dt class="func">forge:literal(value, datatype=nil, language=nil)</dt>
				<dt>value (string)</dt>
					<dd>string value to forge</dd>
				<dt>datatype (integer)</dt>
					<dd>datatype of literal as integer URID, defaults to 0</dd>
				<dt>language (integer)</dt>
					<dd>language of literal as integer URID, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-literal" data-snippet="snippet-forge-literal">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-literal">-- Forge Literal

local tlh = Map['http://lexvo.org/id/iso639-3/tlh'] -- Klingon language

-- serialize
local io = Stash()

io:literal('902A7F', MIDI.MidiEvent) -- MIDI encoded as hexidecimal text
io:literal('', nil, tlh) -- 'hello' aka 'what do you want?'</code></pre>
			</div></div>

			<!-- Forge Chunk -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-chunk">Chunk</h3>
			<p>Forge chunk atom, e.g. of type Atom.Chunk.</p>

			<dl>
				<dt class="func">forge:chunk(value)</dt>
				<dt>value (string)</dt>
					<dd>byte string value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:chunk(value)</dt>
				<dt>value (table)</dt>
					<dd>table with individual values to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:chunk(...)</dt>
				<dt>... (integer)</dt>
					<dd>individual values to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-chunk" data-snippet="snippet-forge-chunk">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-chunk">-- Forge Chunk

-- serialize
local io = Stash()

io:chunk(string.char(0x1, 0x2, 0x3))
io:chunk({0x1, 0x2, 0x3})
io:chunk(0x1, 0x2, 0x3)
</code></pre>
			</div></div>

			<!-- Forge MIDI -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-midi">MIDI</h3>
			<p>Forge MIDI atom, e.g. of type MIDI.MidiEvent.</p>

			<dl>
				<dt class="func">forge:midi(value)</dt>
				<dt>value (string)</dt>
					<dd>byte string value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:midi(value)</dt>
				<dt>value (table)</dt>
					<dd>table with individual values to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:midi(...)</dt>
				<dt>... (integer)</dt>
					<dd>individual values to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-midi" data-snippet="snippet-forge-midi">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-midi">-- Forge MIDI

-- serialize
local io = Stash()

io:chunk(string.char(MIDI.NoteOn, 69, 0x7f))
io:chunk({MIDI.NoteOn, 69, 0x7f})
io:chunk(MIDI.NoteOn, 69, 0x7f)
</code></pre>
			</div></div>

			<!-- Forge Raw -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-raw">Raw</h3>
			<p>Forge a custom atom of arbitrary type.</p>

			<dl>
				<dt class="func">forge:raw(type, value)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>value (string)</dt>
					<dd>byte string value to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:raw(type, value)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>value (table)</dt>
					<dd>table with individual values to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:raw(type, ...)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>... (integer)</dt>
					<dd>individual values to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-raw" data-snippet="snippet-forge-raw">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-raw">-- Forge Raw

local byt = { -- stores individual bytes of zero-terminated string 'LV2'
	string.byte('L'),
	string.byte('V'),
	string.byte('2'),
	string.byte('\0')
}

-- serialize
local io = Stash()

io:raw(Atom.String, string.char(table.unpack(byt)))
io:raw(Atom.String, byt)
io:raw(Atom.String, table.unpack(byt))</code></pre>
			</div></div>

			<!-- Forge Typed -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-typed">Typed</h3>
			<p>Forge an atom of arbitrary type.</p>

			<dl>
				<dt class="func">forge:typed(type, ...)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>... (boolean | integer | number | string | table)</dt>
					<dd>value(s) to forge, see native forge functions documentation</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-typed" data-snippet="snippet-forge-typed">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-typed">-- Forge Typed

-- serialize
local io = Stash()

io:typed(Atom.Int, 12) -- equivalent to io:int(...)
io:typed(Atom.Float, 12.5) -- equivalent to io:float(...)
io:typed(Atom.String, 'LV2 rocks!') -- equivalent to io:string(...)</code></pre>
			</div></div>

			<!-- Forge Atom -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-atom">Atom</h3>
			<p>Forge an unchanged atom. Useful for cloning whole atoms.</p>

			<dl>
				<dt class="func">forge:atom(value)</dt>
				<dt>value (atom)</dt>
					<dd>atom to forge</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-atom" data-snippet="snippet-forge-atom">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-atom">-- Forge Atom

-- serialize
local io1 = Stash()
local io2 = Stash()

-- create integer atom
io1:int(12)
io1:read()

-- forge prepared integer atom in whole
io2:atom(io1)</code></pre>
			</div></div>

		<!-- Forge Container -->
		<div class="api-section"><div class="api-content">
		<h2 id="forge-container">Container</h2>
		<p>Atom types that contain nested atoms as part of their body are referred to
		as containers.</p>
		</div></div>

			<!-- Forge Sequence -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-sequence">Sequence</h3>
			<p>Forge a sequence atom, e.g. an atom of type Atom.Sequence.</p>

			<dl>
				<dt class="func">forge:sequence(unit=0)</dt>
				<dt>unit (integer)</dt>
					<dd>event time unit as integer URID, defaults to 0, can either be Atom.frameTime or Atom.beatTime</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-sequence" data-snippet="snippet-forge-sequence">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-sequence">-- Forge Sequence

-- serialize
local io = Stash()

local seq = io:sequence() -- create derived container forge object
	seq:time(0):int(12)
	seq:frame_time(1):int(13)
seq:pop() -- finalize container

seq = io:sequence(Atom.frameTime) -- create derived container forge object
	seq:time(0):int(12)
	seq:frame_time(1):int(13)
seq:pop() -- finalize container

seq = io:sequence(Atom.beatTime) -- create derived container forge object
	seq:time(0.0):int(12)
	seq:beat_time(1.0):int(13)
seq:pop() -- finalize container</code></pre>
			</div></div>

				<!-- Forge Frame Time-->
				<div class="api-section"><div class="api-content">
				<h4 id="forge-frame-time">Frame Time</h4>
				<p>Forge frame time of event. Use this on sequences with unit 0 or Atom.frameTime.</p>

				<dl>
					<dt class="func">forge:frame_time(frames)</dt>
					<dt>frames (integer)</dt>
						<dd>frame time of event</dd>
					<dt class="ret">(forge)</dt>
						<dd>self forge object</dd>
				</dl>
				</div></div>

				<!-- Forge Beat Time-->
				<div class="api-section"><div class="api-content">
				<h4 id="forge-beat-time">Beat Time</h4>
				<p>Forge beat time of event. Use this on sequences with unit Atom.beatTime.</p>

				<dl>
					<dt class="func">forge:beat_time(beats)</dt>
					<dt>beats (number)</dt>
						<dd>beat time of event</dd>
					<dt class="ret">(forge)</dt>
						<dd>self forge object</dd>
				</dl>
				</div></div>

				<!-- Forge Time-->
				<div class="api-section"><div class="api-content">
				<h4 id="forge-time">Time</h4>
				<p>Forge frame or beat time of event. Can be used as syntactic sugar instead of
				<a href="#forge-frame-time">Frame Time</a> or <a href="#forge-beat-time">Beat Time</a>.</p>

				<dl>
					<dt class="func">forge:time(timestamp)</dt>
					<dt>timestamp (integer | number)</dt>
						<dd>frame time (integer) or beat time (number) of event</dd>
					<dt class="ret">(forge)</dt>
						<dd>self forge object</dd>
				</dl>
				</div></div>

			<!-- Forge Object -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-object">Object</h3>
			<p>Forge an object atom, e.g. an atom of type Atom.Object.</p>

			<dl>
				<dt class="func">forge:object(id=0, otype=0)</dt>
				<dt>id (integer)</dt>
					<dd>object ID as integer URID, defaults to 0</dd>
				<dt>otype (integer)</dt>
					<dd>object type as integer URID, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-object" data-snippet="snippet-forge-object">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-object">-- Forge Object
local urn = HashMap('urn:moony:xyz')

-- serialize
local io = Stash()

local obj = io:object(nil, urn.FooBar) -- create derived container forge object
	obj:key(urn.foo):int(12) -- without context
	obj:key(urn.bar, urn.ctx):long(13) -- with context
obj:pop() -- finalize container</code></pre>
			</div></div>

				<!-- Forge Key -->
				<div class="api-section"><div class="api-content">
				<h4 id="forge-key">Key</h4>
				<p>Forge key of object property.</p>

				<dl>
					<dt class="func">forge:key(value, context=0)</dt>
					<dt>value (integer)</dt>
						<dd>key of property as integer URID</dd>
					<dt>context (integer)</dt>
						<dd>context of property as integer URID, defaults to 0</dd>
					<dt class="ret">(forge)</dt>
						<dd>self forge object</dd>
				</dl>
				</div></div>

			<!-- Forge Tuple -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-tuple">Tuple</h3>
			<p>Forge a tuple atom, e.g. an atom of type Atom.Tuple.</p>

			<dl>
				<dt class="func">forge:tuple()</dt>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-tuple" data-snippet="snippet-forge-tuple">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-tuple">-- Forge Tuple

-- serialize
local io = Stash()

local tup = io:tuple() -- create derived container forge object
	tup:int(12)
	tup:long(13)
	tup:float(13.5)
	tup:double(14.5)
	tup:string('this is an element of an atom tuple')
	tup:bool(true)
tup:pop() -- finalize container</code></pre>
			</div></div>

			<!-- Forge Vector -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-vector">Vector</h3>
			<p>Forge a vector atom, e.g. an atom of type Atom.Vector.</p>

			<dl>
				<dt class="func">forge:vector(type, value)</dt>
					<dt>type (integer)</dt>
						<dd>child type as integer URID, valid are: Atom.Bool, Atom.Int, Atom.Float, Atom.Double, Atom.URID</dd>
					<dt>value (table)</dt>
						<dd>table with vector elements</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<dl>
				<dt class="func">forge:vector(type, ...)</dt>
					<dt>type (integer)</dt>
						<dd>child type as integer URID, valid are: Atom.Bool, Atom.Int, Atom.Float, Atom.Double, Atom.URID</dd>
					<dt>... (bool | integer | number)</dt>
						<dd>vector elements</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-vector" data-snippet="snippet-forge-vector">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-vector">-- Forge Vector

-- serialize
local io = Stash()

io:vector(Atom.Int, 1, 2, 3, 4, 5) -- vector items as individual arguments
io:vector(Atom.Bool, {true, false, true}) --vector items as table</code></pre>
			</div></div>

			<!-- Forge Pop -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-pop">Pop</h3>
			<p>Finalize any derived container forge object.</p>

			<dl>
				<dt class="func">forge:pop()</dt>
			</dl>
			</div></div>

		<!-- Forge OSC -->
		<div class="api-section"><div class="api-content">
		<h2 id="forge-osc">OSC</h2>
		<p>Atom types that contain Open Sound Control bundles or messages as part of their body.</p>
		</div></div>

			<!-- Forge Bundle -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-bundle">Bundle</h3>
			<p>Forge a OSC bundle atom, e.g. an atom object of type OSC.Bundle.</p>

			<dl>
				<dt class="func">forge:bundle(timestamp=1)</dt>
				<dt>timestamp (integer | number)</dt>
					<dd>absolute timestamp in frames (integer) or relative timestamp (number) in seconds, defaults to 1 aka immediate</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-bundle" data-snippet="snippet-forge-bundle">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-bundle">-- Forge Bundle

-- serialize
local io = Stash()

-- schedule bundle for immediate dispatch
local bndl = io:bundle() -- create derived container forge object
	bndl:message('/hello', 's', 'world')
bndl:pop() -- finalize container

-- schedule bundle for dispatch @ Sep 19, 2016 02.09.16.015811000 UTC
bndl = io:bundle(0xdb89c74c040c3199)
	bndl:message('/hello', 's', 'world')
bndl:pop()

-- schedule bundle for dispatch in 0.1s
bndl = io:bundle(0.1)
	bndl:message('/hello', 's', 'world')
bndl:pop()</code></pre>
			</div></div>

			<!-- Forge Message -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-message">Message</h3>
			<p>Forge a OSC message atom, e.g. an atom object of type OSC.Message.
			Supported OSC argument types are: 'i', 'f', 's', 'b', 'h', 'd', 't',
			'm', 'S', 'c', 'r', 'T', 'F', 'N', 'I'</p>

			<dl>
				<dt class="func">forge:message(path, format, ...)</dt>
				<dt>path (string)</dt>
					<dd>OSC path as string</dd>
				<dt>format (string)</dt>
					<dd>OSC format as string</dd>
				<dt>... (integer | number | string)</dt>
					<dd>variable arguments according to format</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-message" data-snippet="snippet-forge-message">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-message">-- Forge Message

-- serialize
local io = Stash()

-- schedule bundle for immediate dispatch
local bndl = io:bundle() -- create derived container forge object
	bndl:message('/hello', 'ifs', 2016, 12.5, 'hello')
	bndl:message('/hello', 'b', string.char(0x1, 0x2, 0x3))
	bndl:message('/hello', 'hdS', 2017, 13.5, 'world')
	bndl:message('/hello', 't', 0xdb89c74c040c3199)
	bndl:message('/hello', 'TFNI')
	bndl:message('/hello', 'm', string.char(MIDI.NoteOn, 69, 0x7f))
	bndl:message('/hello', 'cr', string.byte('s'), 0xff00ff00)
bndl:pop() -- finalize container)</code></pre>
			</div></div>

		<!-- Forge Patch -->
		<div class="api-section"><div class="api-content">
		<h2 id="forge-patch-patch">Patch</h2>
		<p>Atom types that contain Patch messages as part of their body.</p>
		</div></div>

			<!-- Forge Patch-->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-patch">Patch</h3>
			<p>Forge a patch patch atom, e.g. an atom object of type Patch.Patch.</p>

			<dl>
				<dt class="func">forge:patch(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-patch" data-snippet="snippet-forge-patch">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-patch">-- Forge Patch

local urn = HashMap('urn:moony:xzy')

-- serialize
local io = Stash()

local patch= io:patch(urn.subj, 1002) -- with subject and sequence number

	local rem = patch:remove() -- equivalent to patch:object(0, Patch.remove)
		rem:key(urn.foo):urid(Patch.wildcard)
		rem:key(urn.bar):urid(Patch.wildcard)
	rem:pop()

	local add = patch:add() -- equivalent to patch:object(0, Patch.add)
		add:key(urn.foo):int(12)
		add:key(urn.bar):float(12.5)
	add:pop()

patch:pop()</code></pre>
			</div></div>

				<!-- Forge Add -->
				<div class="api-section"><div class="api-content">
				<h4 id="forge-add">Add</h4>
				<p>Forge add property of patch property.</p>

				<dl>
					<dt class="func">forge:add()</dt>
					<dt class="ret">(forge)</dt>
						<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
				</dl>
				</div></div>

				<!-- Forge Add -->
				<div class="api-section"><div class="api-content">
				<h4 id="forge-remove">Remove</h4>
				<p>Forge remove property of patch property.</p>

				<dl>
					<dt class="func">forge:remove()</dt>
					<dt class="ret">(forge)</dt>
						<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
				</dl>
				</div></div>

			<!-- Forge Get -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-get">Get</h3>
			<p>Forge a patch get atom, e.g. an atom object of type Patch.Get.</p>

			<dl>
				<dt class="func">forge:get(property, subject=0, sequenceNumber=0)</dt>
				<dt>property (integer)</dt>
					<dd>patch property as integer URID</dd>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>self container object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-get" data-snippet="snippet-forge-get">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-get">-- Forge Get

local urn = HashMap('urn:moony:xzy')

-- serialize
local io = Stash()

io:get(urn.prop) -- without subject and sequence number
io:get(urn.prop, nil, 1001) -- without subject
io:get(urn.prop, urn.subj, 1002) -- with subject and sequence number</code></pre>
			</div></div>

			<!-- Forge Set -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-set">Set</h3>
			<p>Forge a patch set atom, e.g. an atom object of type Patch.Set.</p>

			<dl>
				<dt class="func">forge:set(property, subject=0, sequenceNumber=0)</dt>
				<dt>property (integer)</dt>
					<dd>patch property as integer URID</dd>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-set" data-snippet="snippet-forge-set">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-set">-- Forge Set

local urn = HashMap('urn:moony:xzy')

-- serialize
local io = Stash()

local set = io:set(urn.prop) -- without subject and sequence number
	set:int(12)
set:pop()

local set = io:set(urn.prop, urn.subj, 1002) -- with subject and sequence number
	set:float(12)
set:pop()</code></pre>
			</div></div>

			<!-- Forge Put -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-put">Put</h3>
			<p>Forge a patch put atom, e.g. an atom object of type Patch.Put.</p>

			<dl>
				<dt class="func">forge:put(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-put" data-snippet="snippet-forge-put">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-put">-- Forge Put

local urn = HashMap('urn:moony:xzy')

-- serialize
local io = Stash()

local put = io:put() -- without subject and sequence number
	put:key(urn.foo):int(12)
	put:key(urn.bar):float(12.5)
put:pop()

local put= io:put(urn.subj, 1002) -- with subject and sequence number
	put:key(urn.foo):int(12)
	put:key(urn.bar):float(12.5)
put:pop()</code></pre>
			</div></div>

			<!-- Forge Ack -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-ack">Ack</h3>
			<p>Forge an ack patch atom, e.g. an atom object of type Patch.Ack.</p>

			<dl>
				<dt class="func">forge:ack(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-ack" data-snippet="snippet-forge-ack">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-ack">-- Forge Ack

local urn = HashMap('urn:moony:xzy')

-- serialize
local io = Stash()

io:ack(urn.subj, 1002) -- with subject and sequence number</code></pre>
			</div></div>

			<!-- Forge Error -->
			<div class="api-section"><div class="api-content">
			<h3 id="forge-error">Error</h3>
			<p>Forge an error patch atom, e.g. an atom object of type Patch.Error.</p>

			<dl>
				<dt class="func">forge:error(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(forge)</dt>
					<dd>self forge object</dd>
			</dl>

			<a class="api-snippet" href="#snippet-forge-error" data-snippet="snippet-forge-error">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-forge-error">-- Forge Error

local urn = HashMap('urn:moony:xzy')

-- serialize
local io = Stash()

io:error(urn.subj, 1002) -- with subject and sequence number</code></pre>
			</div></div>

	<div class="api-section"><div class="api-content">
	<h1 id="atom">Atom</h1>
	<p>Instead of deserializing all LV2 event data to corresponding Lua types,
	Moony instead presents a proxy object to the user in form of a Lua userdata.
	This is needed because there are more LV2 atom types than native Lua types.
	It turns out to be more efficient, too, as the user usually wants to filter
	events before looking at their payload.</p>

	<p>All atom types have some common attributes they can be queried for:</p>

	<dl>
		<dt class="attr">atom.__len | #atom</dt>
		<dt class="ret">(integer)</dt>
			<dd>size of atom body</dd>
	</dl>

	<dl>
		<dt class="attr">atom.__tostring | tostring(atom)</dt>
		<dt class="ret">(string)</dt>
			<dd>string representation of atom</dd>
	</dl>

	<dl>
		<dt class="attr">atom.type</dt>
		<dt class="ret">(integer)</dt>
			<dd>URID of atom type</dd>
	</dl>
	</div></div>

		<!-- Atom Primitive -->
		<div class="api-section"><div class="api-content">
		<h2 id="atom-primitive">Primitive</h2>
		<p>Atom types that contain single data as part of their body are referred to
		as primitives.</p>
		</div></div>

			<!-- Atom Nil -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-nil">Nil</h3>
			<p>An empty atom, e.g. of type and size 0.</p>

			<dl>
				<dt class="attr">nil.__len | #nil</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">nil.__tostring | tostring(nil)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">nil.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">nil.body</dt>
				<dt class="ret">(nil)</dt>
					<dd>atom body as Lua nil</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-nil" data-snippet="snippet-atom-nil">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-nil">-- Atom Nil

-- serialize
local io = Stash()
io:read()

-- attributes
assert(#io == 0) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == 0) -- query type of atom
assert(io.body == nil) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Bool -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-bool">Bool</h3>
			<p>A boolean atom, e.g. of type Atom.Bool and size 4.</p>

			<dl>
				<dt class="attr">bool.__len | #bool</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">bool.__tostring | tostring(bool)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">bool.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">bool.body</dt>
				<dt class="ret">(boolean)</dt>
					<dd>atom body as Lua boolean</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-bool" data-snippet="snippet-atom-bool">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-bool">-- Atom Bool

-- serialize
local io = Stash()
io:bool(true)
io:read()

-- attributes
assert(#io == 4) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Bool) -- query type of atom
assert(io.body == true) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Int -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-int">Int</h3>
			<p>An integer atom, e.g. of type Atom.Int and size 4.</p>

			<dl>
				<dt class="attr">int.__len | #int</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">int.__tostring | tostring(int)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">int.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">int.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom body as Lua integer</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-int" data-snippet="snippet-atom-int">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-int">-- Atom Int

-- serialize
local io = Stash()
io:int(12)
io:read()

-- attributes
assert(#io == 4) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Int) -- query type of atom
assert(io.body == 12) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Long -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-long">Long</h3>
			<p>A long integer atom, e.g. of type Atom.Long and size 8.</p>

			<dl>
				<dt class="attr">long.__len | #long</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">long.__tostring | tostring(long)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">long.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">long.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom body as Lua integer</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-long" data-snippet="snippet-atom-long">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-long">-- Atom Long

-- serialize
local io = Stash()
io:long(13)
io:read()

-- attributes
assert(#io == 8) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Long) -- query type of atom
assert(io.body == 13) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Float -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-float">Float</h3>
			<p>A single-precision float atom, e.g. of type Atom.Float and size 4.</p>

			<dl>
				<dt class="attr">float.__len | #float</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">float.__tostring | tostring(float)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">float.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">float.body</dt>
				<dt class="ret">(number)</dt>
					<dd>atom body as Lua number</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-float" data-snippet="snippet-atom-float">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-float">-- Atom Float

-- serialize
local io = Stash()
io:float(1.5)
io:read()

-- attributes
assert(#io == 4) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Float) -- query type of atom
assert(io.body == 1.5) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Double -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-double">Double</h3>
			<p>A double-precision float atom, e.g. of type Atom.Double and size 8.</p>

			<dl>
				<dt class="attr">double.__len | #double</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">double.__tostring | tostring(double)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">double.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">double.body</dt>
				<dt class="ret">(number)</dt>
					<dd>atom body as Lua number</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-double" data-snippet="snippet-atom-double">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-double">-- Atom Double

-- serialize
local io = Stash()
io:double(1.6)
io:read()

-- attributes
assert(#io == 8) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Double) -- query type of atom
assert(io.body == 1.6) -- get atom body</code></pre>
			</div></div>

			<!-- Atom URID -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-urid">URID</h3>
			<p>An URID atom, e.g. of type Atom.URID and size 4.</p>

			<dl>
				<dt class="attr">urid.__len | #urid</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">urid.__tostring | tostring(urid)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">urid.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">urid.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom body as Lua integer</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-urid" data-snippet="snippet-atom-urid">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-urid">-- Atom URID

-- serialize
local urn = Map['urn:moony:xyz']
local io = Stash()
io:urid(urn)
io:read()

-- attributes
assert(#io == 4) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.URID) -- query type of atom
assert(io.body == urn) -- get atom body</code></pre>
			</div></div>

			<!-- Atom URI -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-uri">URI</h3>
			<p>An URI atom, e.g. of type Atom.URI and variable size. Atom size
			denotes to string size plus zero byte terminator.</p>

			<dl>
				<dt class="attr">uri.__len | #uri</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">uri.__tostring | tostring(uri)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">uri.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">uri.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-uri" data-snippet="snippet-atom-uri">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-uri">-- Atom URI

-- serialize
local urn = 'urn:moony:xyz'
local io = Stash()
io:uri(urn)
io:read()

-- attributes
assert(#io == #urn + 1) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.URI) -- query type of atom
assert(io.body == urn) -- get atom body</code></pre>
			</div></div>

			<!-- Atom String -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-string">String</h3>
			<p>A string atom, e.g. of type Atom.String and variable size. Atom size
			denotes to string size plus zero byte terminator.</p>

			<dl>
				<dt class="attr">string.__len | #string</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">string.__tostring | tostring(string)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">string.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">string.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-string" data-snippet="snippet-atom-string">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-string">-- Atom String

-- serialize
local str = 'hello world'
local io = Stash()
io:string(str)
io:read()

-- attributes
assert(#io == #str + 1) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.String) -- query type of atom
assert(io.body == str) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Path -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-path">Path</h3>
			<p>A path atom, e.g. of type Atom.Path and variable size. Atom size
			denotes to string size plus zero byte terminator.</p>

			<dl>
				<dt class="attr">path.__len | #path</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">path.__tostring | tostring(path)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">path.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">path.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-path" data-snippet="snippet-atom-path">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-path">-- Atom Path

-- serialize
local tmp = '/tmp/xyz'
local io = Stash()
io:path(tmp)
io:read()

-- attributes
assert(#io == #tmp + 1) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Path) -- query type of atom
assert(io.body == tmp) -- get atom body</code></pre>
			</div></div>

			<!-- Atom Literal -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-literal">Literal</h3>
			<p>A literal atom, e.g. of type Atom.Literal and variable size. Atom size
			denotes to string size plus zero byte terminator. Atom literals may have
			either a data type or language attribute.</p>

			<dl>
				<dt class="attr">literal.__len | #literal</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">literal.__tostring | tostring(literal)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">literal.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">literal.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<dl>
				<dt class="attr">literal.datatype</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of data type</dd>
			</dl>

			<dl>
				<dt class="attr">literal.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of language</dd>
			</dl>

			<dl>
				<dt class="func">literal:unpack()</dt>
				<dt class="ret">(string, integer, integer)</dt>
					<dd>atom body as Lua string, URID of data type, URID of language</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-literal" data-snippet="snippet-atom-literal">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-literal">-- Atom  Literal

-- serialize
local lit = 'Hallo Welt'
local datatype = Map['urn:moony:xyz']
local lang = Map['urn:moony:de']
local io = Stash()
io:literal(lit, datatype, lang)
io:read()

-- attributes
assert(#io == 4 + 4 + #lit + 1) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Literal) -- query type of atom
assert(io.datatype == datatype) -- query datatype of literal
assert(io.lang == lang) -- query datatype of literal
assert(io.body == lit) -- get atom body

-- unpacking all attributes
local lit2, datatype2, lang2 = io:unpack()
assert(lit2 == lit)
assert(datatype2 == datatype)
assert(lang2 == lang)</code></pre>
			</div></div>

			<!-- Atom Chunk-->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-chunk">Chunk</h3>
			<p>A chunk atom, e.g. of type Atom.Chunk and variable size. Atom size
			denotes to byte size of atom body.</p>

			<dl>
				<dt class="attr">chunk.__len | #chunk</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">chunk.__tostring | tostring(chunk)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">chunk.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">chunk.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua byte string</dd>
			</dl>

			<dl>
				<dt class="func">chunk:unpack(from=1, to=#chunk)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start byte position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end byte position to unpack from, defaults to body size<dd>
				<dt class="ret">(integer, integer, ...)</dt>
					<dd>atom body unpacked bytewise as Lua integers</dd>
			</dl>

			<dl>
				<dt class="func">chunk:__index(idx) | chunk[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>byte position to query for</dd>
				<dt class="ret">(integer)</dt>
					<dd>byte at position idx of atom body as Lua integer</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-chunk" data-snippet="snippet-atom-chunk">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-chunk">-- Atom Chunk

-- serialize
local byt = string.char(0x1, 0x2, 0x3)
local io = Stash()
io:chunk(byt)
io:read()

-- attributes
assert(#io == #byt) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == Atom.Chunk) -- query type of atom
assert(io.body == byt) -- get atom body

-- unpacking all bytes
local byt1, byt2, byt3 = io:unpack() -- equivalent to io:unpack(1, #io)
assert(byt1 == 0x1)
assert(byt2 == 0x2)
assert(byt3 == 0x3)

-- indexing individual bytes
assert(io[1] == 0x1)
assert(io[2] == 0x2)
assert(io[3] == 0x3)</code></pre>
			</div></div>

			<!-- Atom MIDI -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-midi">MIDI</h3>
			<p>A MIDI atom, e.g. of type MIDI.MidiEvent and variable size. Atom size
			denotes to byte size of atom body. A MIDI atom is an equivalent to a
			Chunk atom and thus features the same class attributes and methods.</p>

			<dl>
				<dt class="attr">midi.__len | #midi</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">midi.__tostring | tostring(midi)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">midi.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">midi.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua byte string</dd>
			</dl>

			<dl>
				<dt class="func">midi:unpack(from=1, to=#midi)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start byte position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end byte position to unpack from, defaults to body size<dd>
				<dt class="ret">(integer, integer, ...)</dt>
					<dd>atom body unpacked bytewise as Lua integers</dd>
			</dl>

			<dl>
				<dt class="func">midi:__index(idx) | midi[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>byte position to query for</dd>
				<dt class="ret">(integer)</dt>
					<dd>byte at position idx of atom body as Lua integer</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-midi" data-snippet="snippet-atom-midi">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-midi">-- Atom MIDI

-- serialize
local byt = string.char(MIDI.NoteOn, 69, 64)
local io = Stash()
io:midi(byt)
io:read()

-- attributes
assert(#io == #byt) -- query size of atom body
print(tostring(io)) -- convert to string
assert(io.type == MIDI.MidiEvent) -- query type of atom
assert(io.body == byt) -- get atom body

-- unpack all bytes
local byt1, byt2, byt3 = io:unpack() -- equivalent to io:unpack(1, #io)
assert(byt1 == MIDI.NoteOn)
assert(byt2 == 69)
assert(byt3 == 64)

-- indexing individual bytes
assert(io[1] == MIDI.NoteOn)
assert(io[2] == 69)
assert(io[3] == 64)</code></pre>
			</div></div>

		<div class="api-section"><div class="api-content">
		<h2 id="atom-container">Container</h2>
		<p>Atom types that contain nested atoms as part of their body are referred to
		as containers.</p>
		</div></div>

			<!-- Atom Sequence -->
			<div class="api-section"><div class="api-content">
			<h3 id="atom-sequence">Sequence</h3>
			<p>A Sequence atom, e.g. of type Atom.Sequence and variable size. Atom size
			denotes to number of events contained in atom body. An atom sequence
			consists of individual atom events, each with a time stamp and event
			pyaload.</p>

			<dl>
				<dt class="attr">seq.__len | #seq</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of events</dd>
			</dl>

			<dl>
				<dt class="attr">seq.__tostring | tostring(seq)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">seq.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">seq.unit</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of event time unit</dd>
			</dl>

			<dl>
				<dt class="func">seq:foreach()</dt>
				<dt class="ret">(integer | number, atom)</dt>
					<dd>iterates over all atom events returning frame or beat time and event atom.</dd>
			</dl>

			<dl>
				<dt class="func">seq:foreach(...)</dt>
				<dt>... (atom)</dt>
					<dd>additional sequence(s) to multiplex and iterate over.</dd>
				<dt class="ret">(integer | number, atom, atom)</dt>
					<dd>multiplexes and iterates over all atom events from all sequences returning frame or beat time, event atom and source sequence atom.</dd>
			</dl>

			<dl>
				<dt class="func">seq:__index(idx) | seq[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>event position to query for</dd>
				<dt class="ret">(atom)</dt>
					<dd>event atom at position idx</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-seq" data-snippet="snippet-atom-seq">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-seq">-- Atom Sequence

-- serialize
local io = Stash()
io:sequence(Atom.frameTime):time(0):int(12):pop()
io:read()

-- attributes
assert(#io == 1) -- query number of events
print(tostring(io)) -- convert to string
assert(io.type == Atom.Sequence) -- query type of atom
assert(io.unit == Atom.frameTime) -- query event time unit

-- iterate over
for frames, atom in io:foreach() do
	assert(frames == 0)
	assert(atom.body == 12)
end
		
-- indexing
local atom = io[1]
assert(atom.body == 12)</code></pre>
			</div></div>

			<!-- Atom Tuple -->
			<div class="api-tuple"><div class="api-content">
			<h3 id="atom-tuple">Tuple</h3>
			<p>A Tuple atom, e.g. of type Atom.Tuple and variable size. Atom size
			denotes to number of items contained in atom body. An atom tuple 
			consists of individual atom items.</p>

			<dl>
				<dt class="attr">tup.__len | #tup</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of items</dd>
			</dl>

			<dl>
				<dt class="attr">tup.__tostring | tostring(tup)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">tup.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="func">tup:unpack(from=1, to=#tup)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end position to unpack from, defaults to body size<dd>
				<dt class="ret">(atom, atom, ...)</dt>
					<dd>atom items unpacked from tuple</dd>
			</dl>

			<dl>
				<dt class="func">tup:foreach()</dt>
				<dt class="ret">(integer, atom)</dt>
					<dd>iterates over all atom items returning index and atom item.</dd>
			</dl>

			<dl>
				<dt class="func">tup:__index(idx) | tup[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>item position to query for</dd>
				<dt class="ret">(atom)</dt>
					<dd>atom item at position idx</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-tuple" data-snippet="snippet-atom-tuple">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-tuple">-- Atom Tuple

-- serialize
local io = Stash()
io:tuple():int(12):pop()
io:read()

-- attributes
assert(#io == 1) -- query number of items
print(tostring(io)) -- convert to string
assert(io.type == Atom.Tuple) -- query type of atom

-- iterate over
for i, atom in io:foreach() do
	assert(i == 1)
	assert(atom.body == 12)
end

-- unpack
local a1 = io:unpack()
assert(a1.body == 12)
		
-- indexing
a1 = io[1]
assert(a1.body == 12)</code></pre>
			</div></div>

			<!-- Atom Object -->
			<div class="api-object"><div class="api-content">
			<h3 id="atom-object">Object</h3>
			<p>An Object atom, e.g. of type Atom.Object and variable size. Atom size
			denotes to number of properties contained in atom body. An atom object 
			consists of individual properties.</p>

			<dl>
				<dt class="attr">obj.__len | #obj</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of properties</dd>
			</dl>

			<dl>
				<dt class="attr">obj.__tostring | tostring(obj)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">obj.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">obj.id</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom object ID</dd>
			</dl>

			<dl>
				<dt class="attr">obj.otype</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom object type</dd>
			</dl>

			<dl>
				<dt class="func">obj:foreach()</dt>
				<dt class="ret">(integer, atom, integer)</dt>
					<dd>iterates over all properties returning property key, atom and context.</dd>
			</dl>

			<dl>
				<dt class="func">obj:__index(key) | obj[key]</dt>
				<dt>key (integer)</dt>
					<dd>URID of key to query for</dd>
				<dt class="ret">(atom)</dt>
					<dd>property atom for key</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-object" data-snippet="snippet-atom-object">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-object">-- Atom Object

-- serialize
local urn = Map['urn:moony:xyz']
local io = Stash()
io:object():key(urn):int(12):pop()
io:read()

-- attributes
assert(#io == 1) -- query number of properties
print(tostring(io)) -- convert to string
assert(io.type == Atom.Object) -- query type of atom

-- iterate over
for k, atom, ctx in io:foreach() do
	assert(k == urn)
	assert(atom.body == 12)
	assert(ctx == 0)
end
		
-- indexing
local atom = io[urn]
assert(atom.body == 12)</code></pre>
			</div></div>

			<!-- Atom Vector -->
			<div class="api-vector"><div class="api-content">
			<h3 id="atom-vector">Vector</h3>
			<p>A Vector atom, e.g. of type Atom.Vector and variable size. Atom size
			denotes to number of items contained in atom body. An atom vector 
			consists of equally typed atom items.</p>

			<dl>
				<dt class="attr">vec.__len | #vec</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of items</dd>
			</dl>

			<dl>
				<dt class="attr">vec.__tostring | tostring(vec)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">vec.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">vec.child_size</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom vector child size</dd>
			</dl>

			<dl>
				<dt class="attr">vec.child_type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom vector child type</dd>
			</dl>

			<dl>
				<dt class="func">vec:unpack(from=1, to=#vec)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end position to unpack from, defaults to body size<dd>
				<dt class="ret">(atom, atom, ...)</dt>
					<dd>atom items unpacked from vector</dd>
			</dl>

			<dl>
				<dt class="func">vec:foreach()</dt>
				<dt class="ret">(integer, atom)</dt>
					<dd>iterates over all vector items returning index and atom.</dd>
			</dl>

			<dl>
				<dt class="func">vec:__index(idx) | vec[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>position to query for</dd>
				<dt class="ret">(atom)</dt>
					<dd>atom of item at position idx</dd>
			</dl>

			<a class="api-snippet" href="#snippet-atom-vector" data-snippet="snippet-atom-vector">&rArr; show snippet</a>
			<pre class="api-hidden"><code id="snippet-atom-vector">-- Atom Vector

-- serialize
local io = Stash()
io:vector(Atom.Int, 12, 13, 14)
io:read()

-- attributes
assert(#io == 3) -- query number of items
print(tostring(io)) -- convert to string
assert(io.type == Atom.Vector) -- query type of atom
assert(io.child_size == 4) -- query child size of atom
assert(io.child_type == Atom.Int) -- query child type of atom

-- iterate over
for i, atom in io:foreach() do
	if i == 1 then
		assert(atom.body == 12)
	elseif i == 2 then
		assert(atom.body == 13)
	elseif i == 3 then
		assert(atom.body == 14)
	end
end

-- unpack
local v1, v2, v3 = io:unpack()
assert(v1.body == 12)
assert(v2.body == 13)
assert(v3.body == 14)
		
-- indexing
v1, v2, v3 = io[1], io[2], io[3]
assert(v1.body == 12)
assert(v2.body == 13)
assert(v3.body == 14)</code></pre>
			</div></div>

	<!-- Stash -->
	<div class="api-section"><div class="api-content">
	<h1 id="stash">Stash</h1>
	<p>Sometimes it may be useful to not only be able to serialize atoms to forge
	objects provided to the user via one of the callback functions, but to be able
	to temporarily serialize some atoms to memory for later dispatch.</p>

	<p>For these usage scenarios there is the stash object, which according to
	its name, functions as temporary stash. It is a special object in the way
	that it can either be an atom object (with all its attributes and methods)
	or a forge object (with all its methods), depending on whether it is in its
	reading or writing mode.</p>

	<p>After creating a new stash, it is in its writing mode and thus can be used
	just like a forge object. After finishing the serialization procedure, the
	stash object may be switched into its reading mode and be used just like
	an atom object.</p>

		<dl>
			<dt class="func">stash:read()</dt>
			<dt class="ret">(atom)</dt>
				<dd>reference to self as atom object to read from</dd>
		</dl>

		<dl>
			<dt class="func">stash:write()</dt>
			<dt class="ret">(forge)</dt>
				<dd>reference to self as forge object to write to</dd>
		</dl>

		<a class="api-snippet" href="#snippet-stash" data-snippet="snippet-stash">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-stash">-- Stash

-- a new stash defaults to writing mode - equivalent to forge object
local io = Stash()
io:int(12)

-- switch to reading mode - equivalent to atom object
io:read()
assert(io.body == 12)

-- switch to writing mode - automatically clears previous content
io:write()
io:int(13)

-- switch to reading mode
io:read()
assert(io.body == 13)</code></pre>
		</div></div>

	<!-- Responder -->
	<div class="api-section"><div class="api-content">
	<h1 id="responder">Responder</h1>
	<p>Responders are convenience wrappers to ease development of frequently used
	logic event handling schemes via callbacks.</p>

	<p>Moony offers simple responders for MIDI and OSC handling and more complex
	responders for time and state handling.</p>

	<p>By using responder objects, common problems like event filtering and
	sequencing can be written with much less and more understandable code.</p>

	<p>The StateResponder can be used to build simple user interfaces to make
	any moony script available to non-coders around the world.</p>

	</div></div>

		<!-- MIDIResponder -->
		<div class="api-section"><div class="api-content">
		<h2 id="responder-midi">MIDIResponder</h2>
		<p>Runs callbacks for received MIDI messages.</p>

		<dl>
			<dt class="func">MIDIResponder(responder, through=false)</dt>
			<dt>responder (table)</dt>
				<dd>table with responder callbacks</dd>
			<dt>through (boolean)</dt>
				<dd>flag whether to let unhandled messages through, defaults to false</dd>
			<dt class="ret">(userdata)</dt>
				<dd>MIDIResponder object</dd>
		</dl>

		<dl>
			<dt class="func">midiR:__call(frames, forge, atom) | midiR(frames, forge, atom)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of event</dd>
			<dt>forge (forge)</dt>
				<dd>forge object</dd>
			<dt>atom (atom)</dt>
				<dd>atom body of event</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether the event was handled, e.g. whether is was any MIDI at all</dd>
		</dl>

		<a class="api-snippet" href="#snippet-responder-midi" data-snippet="snippet-responder-midi">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-responder-midi">-- MIDIResponder

-- define MIDI responder object with callbacks
local midiR = MIDIResponder({
	[MIDI.NoteOn] = function(self, frames, forge, chan, note, vel)
		assert(frames == 0)
		assert(chan == 0x1)
		assert(note == 69)
		assert(vel == 0x7f)

		forge:time(frames):midi(MIDI.NoteOn | chan, note + 1, vel) -- increase note by 1
	end,
	[MIDI.NoteOff] = function(self, frames, forge, chan, note, vel)
		assert(frames == 1)
		assert(chan == 0x1)
		assert(note == 69)
		assert(vel == 0x0)

		forge:time(frames):midi(MIDI.NoteOff | chan, note + 1, vel) -- increase note by 1
	end
}, false) -- block all MIDI messages not explicitly handled by responder

-- define run function
function run(n, seq, forge, control, notify)
	for frames, atom in seq:foreach() do
		local handled = midiR(frames, forge, atom)
	end
end

local io1 = Stash()
local io2 = Stash()

-- define test sequence of MIDI events
local seq1 = io1:sequence()
	seq1:time(0):midi(MIDI.NoteOn | 0x1, 69, 0x7f)
	seq1:time(1):midi(MIDI.NoteOff | 0x1, 69, 0x0)
	seq1:time(2):midi(MIDI.Bender | 0x1, 0x0, 0x7f)
seq1:pop()

io1:read()

-- run test sequence through run function
local seq2 = io2:sequence()
run(256, io1, seq2)
seq2:pop()

io2:read()

assert(#io2 == 2)</code></pre>
		</div></div>

		<!-- OSCResponder -->
		<div class="api-section"><div class="api-content">
		<h2 id="responder-osc">OSCResponder</h2>
		<p>Runs callbacks for received OSC messages.</p>

		<dl>
			<dt class="func">OSCResponder(responder)</dt>
			<dt>responder (table)</dt>
				<dd>table with responder callbacks</dd>
			<dt class="ret">(userdata)</dt>
				<dd>OSCResponder object</dd>
		</dl>

		<dl>
			<dt class="func">oscR:__call(frames, forge, atom) | oscR(frames, forge, atom)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of event</dd>
			<dt>forge (forge)</dt>
				<dd>forge object</dd>
			<dt>atom (atom)</dt>
				<dd>atom body of event</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether the event was handled, e.g. whether is was any OSC at all</dd>
		</dl>

		<a class="api-snippet" href="#snippet-responder-osc" data-snippet="snippet-responder-osc">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-responder-osc">-- OSCResponder

-- define OSC responder object with callbacks
local oscR = OSCResponder({
	-- listen for '/ping'
	['/ping'] = function(self, frames, forge, fmt, var1, var2) 
		assert(frames == 0)
		assert(fmt == 'if')
		assert(var1 == 12)
		assert(var2 == 12.5)

		-- send a '/pong'
		forge:time(frames):message('/pong', fmt, var1, var2) 
	end
})

-- define run function
function run(n, seq, forge, control, notify)
	for frames, atom in seq:foreach() do
		local handled = oscR(frames, forge, atom)
	end
end
	
local io1 = Stash()
local io2 = Stash()

-- define test sequence of OSC messages
local seq1 = io1:sequence()
	seq1:time(0):message('/ping', 'if', 12, 12.5)
seq1:pop()

io1:read()

-- run test sequence through run function
local seq2 = io2:sequence()
run(256, io1, seq2)
seq2:pop()

io2:read()

assert(#io2 == 1)</code></pre>

		<!-- TimeResponder -->
		<div class="api-section"><div class="api-content">
		<h2 id="responder-time">TimeResponder</h2>
		<p>...</p>
		</div></div>

		<!-- StateResponder -->
		<div class="api-section"><div class="api-content">
		<h2 id="responder-state">StateResponder</h2>
		<p>...</p>
		</div></div>

	<!-- Utilities -->
	<div class="api-section"><div class="api-content">
	<h1 id="util">Utilities</h1>
	<p>...</p>
	</div></div>

		<!-- midi2cps -->
		<div class="api-section"><div class="api-content">
		<h2 id="util-midi2cps">midi2cps</h2>
		<p>Conversion from MIDI note to Hertz.</p>

		<dl>
			<dt class="func">midi2cps(note)</dt>
			<dt>note (number)</dt>
				<dd>MIDI note, fractions are allowed</dd>
			<dt class="ret">(number)</dt>
				<dd>corresponding frequency in Hz</dd>
		</dl>

		<a class="api-snippet" href="#snippet-util-midi2cps" data-snippet="snippet-util-midi2cps">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-util-midi2cps">-- midi2cps

assert(midi2cps(69.0) == 440.0)</code></pre>
		</div></div>

		<!-- cps2midi -->
		<div class="api-section"><div class="api-content">
		<h2 id="util-cps2midi">cps2midi</h2>
		<p>Conversion from Hertz to MIDI note.</p>

		<dl>
			<dt class="func">cps2midi(cps)</dt>
			<dt>cps (number)</dt>
				<dd>frequency in Hz</dd>
			<dt class="ret">(number)</dt>
				<dd>corresponding MIDI note</dd>
		</dl>

		<a class="api-snippet" href="#snippet-util-cps2midi" data-snippet="snippet-util-cps2midi">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-util-cps2midi">-- cps2midi

assert(cps2midi(440.0) == 69.0)</code></pre>
		</div></div>

		<!-- encrypt -->
		<div class="api-section"><div class="api-content">
		<h2 id="util-encrypt">Encrypt</h2>
		<p>AES-128 encryption of byte strings.</p>

		<dl>
			<dt class="func">encrypt(value, pass)</dt>
			<dt>value (string)</dt>
				<dd>clear text byte string to encode</dd>
			<dt>pass (string)</dt>
				<dd>128-bit passphrase, either as raw byte string or as hex-encoded string</dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding secret byte string</dd>
		</dl>

		<a class="api-snippet" href="#snippet-util-encrypt" data-snippet="snippet-util-encrypt">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-util-encrypt">-- encrypt

local pass = '2b7e151628aed2a6abf7158809cf4f3c'
local value = 'hello world'

local secret = encrypt(value, pass)
assert(decrypt(secret, pass) == value)</code></pre>
		</div></div>

		<!-- decrypt -->
		<div class="api-section"><div class="api-content">
		<h2 id="util-decrypt">Decrypt</h2>
		<p>AES-128 decryption of byte strings.</p>

		<dl>
			<dt class="func">decrypt(value, pass)</dt>
			<dt>value (string)</dt>
				<dd>secret byte string to decode </dd>
			<dt>pass (string)</dt>
				<dd>128-bit passphrase, either as raw byte string or as hex-encoded string</dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding clear text byte string</dd>
		</dl>

		<a class="api-snippet" href="#snippet-util-decrypt" data-snippet="snippet-util-decrypt">&rArr; show snippet</a>
		<pre class="api-hidden"><code id="snippet-util-decrypt">-- decrypt

local pass = string.char(
	0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
	0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c)
local value = 'hello world'

local secret = encrypt(value, pass)
assert(decrypt(secret, pass) == value)</code></pre>
		</div></div>

	<div class="api-section"><div class="api-content">
	<h1 id="license">License</h1>
		<p>Copyright &copy; 2015-2016 Hanspeter Portner
		(<a href="mailto:dev@open-music-kontrollers.ch">dev@open-music-kontrollers.ch</a>)</p>

		<p>This is free software: you can redistribute it and/or modify
		it under the terms of the Artistic License 2.0 as published by
		The Perl Foundation.</p>

		<p>This source is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
		Artistic License 2.0 for more details.</p>

		<p>You should have received a copy of the Artistic License 2.0
		along the source as a COPYING file. If not, obtain it from
		<a href="http://www.perlfoundation.org/artistic_license_2_0"> http://www.perlfoundation.org/artistic_license_2_0</a>.</p>

		<p>
			This site uses <a href="http://www.gnu.org/software/librejs">libre</a> <a href="libreJS.html" data-jslicense="1">javascript</a>
		</p>
	</div></div>

<div class="api-editor">
	<div id="editor">-- moony manual
	
-- load a code snippet from the left!</div>
</div>

<script type="text/javascript">
	// @license magnet:?xt=urn:btih:54fd2283f9dbdf29466d2df1a98bf8f65cafe314&dn=artistic-2.0.txt Artistic-2.0
	var old_body = undefined;
	function set_snippet(snippet_id) {
		if(snippet_id) {
			var snippet_body = $('#'+snippet_id).html();
			if(snippet_body && (snippet_body != old_body)) {
				editor.setValue(snippet_body);
				editor.clearSelection();
				old_body = snippet_body;
			}
		}
	}

	$(document).ready(function() {
		// configure editor
		var session = null;
		editor = ace.edit("editor");
		session = editor.getSession();

		editor.setTheme("ace/theme/chaos");
		editor.setReadOnly(true);
		session.setUseWorker(false);
		session.setMode("ace/mode/lua");

		editor.$blockScrolling = Infinity
		editor.setOptions({
			minLines: 1,
			maxLines: Infinity,
			showPrintMargin: false,
			fontSize: 14,
			tabSize: 2,
			displayIndentGuides: false
		});

		// show editor container
		$('.api-editor').show();

		// show snippet links
		$('.api-snippet').show();

		// hide code snippets
		$('.api-hidden').hide();

		// wire snippet links with code editor
		$('.api-snippet').on('click', function(e) {
			var snippet_id = $(this).data('snippet');
			set_snippet(snippet_id);
			e.preventDefault();
		});

		// show matching code snippet
		$(window).on('scroll', function() {
			var snippet_id = undefined;
			var stop = $(window).scrollTop();
			var ytop = -1;

			$('.api-snippet').each(function() {
				var dtop = $(this).offset().top;

				if( (stop <= dtop) && ( (dtop <= ytop) || (ytop < 0) ) ) {
					snippet_id = $(this).data('snippet');
					ytop = dtop;
				}
			});
			set_snippet(snippet_id);
		});
	});
	// @license-end
</script>

</html>
