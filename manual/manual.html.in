<!DOCTYPE html>
<html lang="en">

<head>
	<title>Moony Manual</title>
	<meta name="author" content="Hanspeter Portner" />
	<meta charset="UTF-8" />
	<link rel="icon" type="image/png" href="moony_logo.png" />
	<style type="text/css">
html, body {
	font-family:sans-serif;
	font-size:14px;
	color:#dddddd;
  background-color:#343434;
	padding:0;
	margin:0;
}

.api-menu {
	position:fixed;
	top:0;
	height:100%;
	left:0;
	width:20%;
	overflow-x:auto;
	overflow-y:auto;
}

.api-body {
	margin-left:20%;
	width:80%;
}

.api-section {
	background-color: #2d2d2d;
	margin:1em;
	padding:1em;
}

a {
	color:#dddddd;
}

a:visited {
	color:#dddddd;
}

a:hover {
	color:#343434;
	background-color:#dddddd;
}

dl {
	border:1px solid #414141;
}

dt {
	font-family:monospace;
	padding-left:1em;
	padding-right:1em;
	padding-top:0.5em;
	padding-bottom:0.5em;
	font-weight:bold;
}

dt.func {
	border-bottom:1px solid #414141;
	color:#00aeef;
	font-weight:bold;
	background-color:#262626;
}

dt.attr {
	border-bottom:1px solid #414141;
	color:#ff6600;
	font-weight:bold;
	background-color:#262626;
}

dt.ret {
	border-top:1px dashed #414141;
	font-weight:bold;
}

dd {
	padding-left:1em;
	padding-right:1em;
	padding-top:0.5em;
	padding-bottom:0.5em;
	font-style:italic;
}

pre {
	background-color:#262626;
	padding:1em;
	border:1px solid #414141;
}
</style>
</head>

<body>

<div class="api-menu">
	<h1>Moony.lv2</h1>
	<h4>@MOONY_VERSION@</h4>
	<h2>Reference manual</h2>

	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>

		<li><a href="#variants">Plugin Variants</a>
			<ul>
				<li><a href="#variants-c1xc1">C1 x C1</a></li>
				<li><a href="#variants-c2xc2">C2 x C2</a></li>
				<li><a href="#variants-c4xc4">C4 x C4</a></li>
				<li><a href="#variants-a1xa1">A1 x A1</a></li>
				<li><a href="#variants-a2xa2">A2 x A2</a></li>
				<li><a href="#variants-a4xa4">A4 x A4</a></li>
				<li><a href="#variants-c1a1xc1a1">C1+A1 x C1+A1</a></li>
				<li><a href="#variants-c2a1xc2a1">C2+A1 x C2+A1</a></li>
				<li><a href="#variants-c4a1xc4a1">C4+A1 x C4+A1</a></li>
			</ul>
		</li>

		<li><a href="#log-and-debug">Log &amp; Debug</a>
		</li>

		<li><a href="#callbacks">Callbacks</a>
			<ul>
				<li><a href="#callbacks-run">run</a></li>
				<li><a href="#callbacks-once">once</a></li>
				<li><a href="#callbacks-stash">stash</a></li>
				<li><a href="#callbacks-apply">apply</a></li>
				<li><a href="#callbacks-save">save</a></li>
				<li><a href="#callbacks-restore">restore</a></li>
			</ul>
		</li>

		<li><a href="#urid">Map &amp; Unmap</a>
			<ul>
				<li><a href="#urid-map">Map</a></li>
				<li><a href="#urid-unmap">Unmap</a></li>
				<li><a href="#urid-hashmap">HashMap</a></li>
				<li><a href="#urid-voicemap">VoiceMap</a></li>
			</ul>
		</li>

		<li><a href="#forge">Forge</a>
			<ul>
				<li><a href="#forge-primitive">Primitive</a>
					<ul>
						<li><a href="#forge-bool">Bool</a></li>
						<li><a href="#forge-int">Int</a></li>
						<li><a href="#forge-long">Long</a></li>
						<li><a href="#forge-float">Float</a></li>
						<li><a href="#forge-double">Double</a></li>
						<li><a href="#forge-urid">URID</a></li>
						<li><a href="#forge-uri">URI</a></li>
						<li><a href="#forge-string">String</a></li>
						<li><a href="#forge-path">Path</a></li>
						<li><a href="#forge-literal">Literal</a></li>
						<li><a href="#forge-chunk">Chunk</a></li>
						<li><a href="#forge-midi">MIDI</a></li>
						<li><a href="#forge-raw">Raw</a></li>
						<li><a href="#forge-typed">Typed</a></li>
						<li><a href="#forge-atom">Atom</a></li>
					</ul>
				</li>
				<li><a href="#forge-container">Container</a>
					<ul>
						<li><a href="#forge-sequence">Sequence</a>
							<ul>
								<li><a href="#forge-frame-time">Frame Time</a></li>
								<li><a href="#forge-beat-time">Beat Time</a></li>
								<li><a href="#forge-time">Time</a></li>
							</ul>
						</li>
						<li><a href="#forge-object">Object</a>
							<ul>
								<li><a href="#forge-key">Key</a></li>
							</ul>
						</li>
						<li><a href="#forge-tuple">Tuple</a></li>
						<li><a href="#forge-vector">Vector</a></li>
						<li><a href="#forge-pop">Pop</a></li>
						<li><a href="#forge-autopop">Autopop</a></li>
					</ul>
				</li>
				<li><a href="#forge-osc">OSC</a>
					<ul>
						<li><a href="#forge-bundle">Bundle</a></li>
						<li><a href="#forge-message">Message</a>
							<ul>
								<li><a href="#forge-impulse">Impulse</a></li>
								<li><a href="#forge-char">Char</a></li>
								<li><a href="#forge-rgba">RGBA</a></li>
								<li><a href="#forge-timetag">Timetag</a></li>
							</ul>
						</li>
					</ul>
				</li>
				<li><a href="#forge-patch-patch">Patch</a>
					<ul>
						<li><a href="#forge-patch">Patch</a>
							<ul>
								<li><a href="#forge-add">Add</a></li>
								<li><a href="#forge-remove">Remove</a></li>
							</ul>
						</li>
						<li><a href="#forge-get">Get</a></li>
						<li><a href="#forge-set">Set</a></li>
						<li><a href="#forge-put">Put</a></li>
						<li><a href="#forge-ack">Ack</a></li>
						<li><a href="#forge-error">Error</a></li>
					</ul>
				</li>
			</ul>
		</li>

		<li><a href="#atom">Atom</a>
			<ul>
				<li><a href="#atom-primitive">Primitive</a>
					<ul>
						<li><a href="#atom-nil">Nil</a></li>
						<li><a href="#atom-bool">Bool</a></li>
						<li><a href="#atom-int">Int</a></li>
						<li><a href="#atom-long">Long</a></li>
						<li><a href="#atom-float">Float</a></li>
						<li><a href="#atom-double">Double</a></li>
						<li><a href="#atom-urid">URID</a></li>
						<li><a href="#atom-uri">URI</a></li>
						<li><a href="#atom-string">String</a></li>
						<li><a href="#atom-path">Path</a></li>
						<li><a href="#atom-literal">Literal</a></li>
						<li><a href="#atom-chunk">Chunk</a></li>
						<li><a href="#atom-midi">MIDI</a></li>
					</ul>
				</li>
				<li><a href="#atom-container">Container</a>
					<ul>
						<li><a href="#atom-sequence">Sequence</a></li>
						<li><a href="#atom-tuple">Tuple</a></li>
						<li><a href="#atom-object">Object</a></li>
						<li><a href="#atom-vector">Vector</a></li>
					</ul>
				</li>
			</ul>
		</li>

		<li><a href="#stash">Stash</a></li>

		<li><a href="#options">Options</a></li>

		<li><a href="#responder">Responder</a>
			<ul>
				<li><a href="#responder-midi">MIDIResponder</a></li>
				<li><a href="#responder-osc">OSCResponder</a></li>
				<li><a href="#responder-time">TimeResponder</a></li>
				<li><a href="#responder-state">StateResponder</a>
					<ul>
						<li><a href="#responder-parameter">Parameter</a></li>
					</ul>
				</li>
			</ul>
		</li>

		<li><a href="#util">Utilities</a>
			<ul>
				<li><a href="#util-midi2cps">midi2cps</a></li>
				<li><a href="#util-cps2midi">cps2midi</a></li>
				<li><a href="#util-note">Note</a></li>
				<li><a href="#util-aes128">AES-128</a>
					<ul>
						<li><a href="#util-aes128-encode">Encode</a></li>
						<li><a href="#util-aes128-decode">Decode</a></li>
					</ul>
				</li>
				<li><a href="#util-base64">Base64</a>
					<ul>
						<li><a href="#util-base64-encode">Encode</a></li>
						<li><a href="#util-base64-decode">Decode</a></li>
					</ul>
				</li>
				<li><a href="#util-ascii85">Ascii85</a>
					<ul>
						<li><a href="#util-ascii85-encode">Encode</a></li>
						<li><a href="#util-ascii85-decode">Decode</a></li>
					</ul>
				</li>
			</ul>
		</li>

		<li><a href="#constants">Constants</a></li>

		<li><a href="#license">License</a>
		</li>
	</ul>
</div>

<div class="api-body">

	<div>
		<img src="moony_logo.png" alt="Moony logo" style="display:block; margin:0 auto;" />
	</div>

	<div class="api-section">
	<h1 id="introduction">Introduction</h1>
		<p>The design goal of the plugin bundle was to create a tool to easily add realtime programmable logic glue in LV2 plugin graphs.</p>

		<p>To have plugins which do a specific task efficiently is great, especially for audio plugins. LV2 stands apart from other audio plugin specifications with its extentable event system based on Atoms. As events can be much more varied in nature and represent pretty much anything (NOT ONLY MIDI), it would be useful to have a tool to create arbitrary event filters for a given setup on-the-fly.</p>

		<p>For a given setup, one may need a special event filter only once and it seems to be overkill to write a native LV2 event filter in C/C++ just for that. It would also be nice to have a tool for fast prototyping of new event filters.</p>

		<p>A scripting language seems to be ideal for these cases, where the user can write an event filter on a higher level of abstraction on-the-fly. The scripting language needs to be realtime safe, though, which restricts the choices dramatically.</p>

		<p>One such scripting language is Lua. It is small, fast, easily embeddable and realtime-safe if coupled to a realtime-safe memory allocator like TLSF.</p>

		<p>The Moony plugins can handle LV2 control and atom event ports, only. They do not handle LV2 audio ports. They may eventually handle LV2 control-voltage ports in the future, though. Control port values are internally handled as simple floating point numbers, whereas the atom event ports build on top of the LV2 atom and atom forge C headers.</p>
	</div>

	<div class="api-section">
	<h1 id="variants">Plugin Variants</h1>
		<p>The Moony plugin bundle ships with multiple plugin variants, whereas all of them share the same
			API but with different configurations of input and output ports. Depending on the users's usage
			scenario, one or the other variant may be preferable.</p>
		<p>Plugin variants only differ in number of control and atom event input and output ports. Apart
			from this difference, they can often be used interchangeably.</p>
	</div>

		<div class="api-section">
		<h2 id="variants-c1xc1">C1 x C1</h2>
		<p>This plugin variant features a single control port input and a single control port output.</p>

		<pre><code data-ref="variants-c1xc1">-- C1 x C1 prototype 'run' function

function run(n, control, notify, c)
	return c
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-c2xc2">C2 x C2</h2>
		<p>This plugin variant features two control port inputs and two control port outputs.</p>

		<pre><code data-ref="variants-c2xc2">-- C2 x C2 prototype 'run' function

function run(n, control, notify, c1, c2)
	return c1, c2
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-c4xc4">C4 x C4</h2>
		<p>This plugin variant features four control port inputs and four control port outputs.</p>

		<pre><code data-ref="variants-c4xc4">-- C4 x C4 prototype 'run' function

function run(n, control, notify, c1, c2, c3, c4)
	return c1, c2, c3, c4
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-a1xa1">A1 x A1</h2>
		<p>This plugin variant features a single atom port input and a single atom port output.</p>

		<pre><code data-ref="variants-a1xa1">-- A1 x A1 prototype 'run' function

function run(n, control, notify, seq, forge)
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-a2xa2">A2 x A2</h2>
		<p>This plugin variant features two atom port inputs and two atom port outputs.</p>

		<pre><code data-ref="variants-a2xa2">-- A2 x A2 prototype 'run' function

function run(n, control, notify, seq1, forge1, seq2, forge2)
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-a4xa4">A4 x A4</h2>
		<p>This plugin variant features four atom port inputs and four atom port outputs.</p>

		<pre><code data-ref="variants-a4xa4">-- A4 x A4 prototype 'run' function

function run(n, control, notify, seq1, forge1, seq2, forge2, seq3, forge3, seq4, forge4)
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-c1a1xc1a1">C1+A1 x C1+A1</h2>
		<p>This plugin variant features a single control port input and a single control port output
			with a single atom port input and a single atom port output.</p>

		<pre><code data-ref="variants-c1a1xc1a1">-- C1+A1 x C1+A1 prototype 'run' function

function run(n, control, notify, seq, forge, c)
	return c
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-c2a1xc2a1">C2+A1 x C2+A1</h2>
		<p>This plugin variant features two control port inputs and two control port outputs
			with a single atom port input and a single atom port output.</p>

		<pre><code data-ref="variants-c2a1xc2a1">-- C2+A1 x C2+A1 prototype 'run' function

function run(n, control, notify, seq, forge, c1, c2)
	return c1, c2
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="variants-c4a1xc4a1">C4+A1 x C4+A1</h2>
		<p>This plugin variant features four control port inputs and four control port outputs
			with a single atom port input and a single atom port output.</p>

		<pre><code data-ref="variants-c4a1xc4a1">-- C4+A1 x C4+A1 prototype 'run' function

function run(n, control, notify, seq, forge, c1, c2, c3, c4)
	return c1, c2, c3, c4
end</code></pre>
		</div>

	<div class="api-section">
	<h1 id="log-and-debug">Log &amp; Debug</h1>
		<p>Whenever you want to log or debug something while developing your scripts, you can easily dump any value via Lua's <b>print</b> function. The print's output will be shown on the UI and also be sent to the host's log backend, e.g. to a log window or console.</p>

	<pre><code data-ref="log-and-debug">-- sends 'hello world' to the UI and the host's log backend

print('hello world')</code></pre>
	</div>

	<div class="api-section">
	<h1 id="callbacks">Callbacks</h1>
	<p>Moony can run user defined callbacks at different positions in its
	processing graph. If the user provides an implementation for a specific
	callback, Moony will run the latter. If the plugin does not need a specific
	callback, the latter can simply be omitted. The implementations of all
	callbacks are thus optional.</p>
	</div>

		<div class="api-section">
		<h2 id="callbacks-run">run</h2>
		<p>The <b>run</b> callback function is the main callback function and thus the most
		important one. It is called once per period by the plugin host. The period size,
		e.g. the number of audio samples the function is called for may be chosen
		arbitrary by the host. Do not expect it to be constant.</p>

		<p>Depending on the plugin variant, the <b>run</b> function takes variable amount
		of arguments. All variants have the first and last two arguments in common, though.</p>

		<p>If a plugin has input event ports, sequence objects (Lua userdata) will be
		given to the <b>run</b> function whose events can be iterated over.</p>

		<p>If a plugin has output event ports, forge objects (Lua userdata) will be
		given to the <b>run</b> function which can be filled with arbitrary atom event
		structures.</p>

		<p>If a plugin has input control ports, those values will be given to the <b>run</b>
		function as native Lua numbers.</p>

		<p>If a plugin has output control ports, the <b>run</b> function is expected to
		return native Lua numbers, missing return values will be set to 0.0.</p>

		<dl>
			<dt class="func">function run(n, control, notify, seq1, forge1, ..., c1, ...)</dt>
			<dt>n (integer)</dt>
				<dd>number of audio samples of current period</dd>
			<dt>{control, notify} (userdata, userdata)</dt>
				<dd>pair of atom sequence and atom forge object for communication with UI</dd>
			<dt>{seq, forge} [x] (userdata, userdata)</dt>
				<dd>pairs of atom sequence and atom forge objects, with x=[0, 1, 2, 4]</dd>
			<dt>c [x] (number)</dt>
				<dd>control port inputs, with x=[0, 1, 2, 4]</dd>
			<dt class="ret">(number)</dt>
				<dd>control port outputs, with x=[0, 1, 2, 4]</dd>
		</dl>

		<pre><code data-ref="callbacks-run">-- 'run' callback prototype for moony#a1xa1

function run(n, control, notify, seq, forge)
	-- here we will process events
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="callbacks-once">once</h2>
		<p>The <b>once</b> function exists for pure convenience only. It has exactly the
		same form as the <b>run</b> function, but is called only once after the whole
		script code is loaded or updated.</p>

		<p>The <b>once</b> function will run directly before the <b>run</b> function,
		it therefore is no replacement for the latter in a given update period, but
		and extension to it.</p>

		<p>Put logic here that needs to run once after script code update, e.g. registering
		a new <a href="#state-responder">StateResponder</a>.</p>

		<dl>
			<dt class="func">function once(n, control, notify, seq1, forge1, ..., c1, ...)</dt>
			<dt>n (integer)</dt>
				<dd>number of audio samples of current period</dd>
			<dt>{control, notify} (userdata, userdata)</dt>
				<dd>pair of atom sequence and atom forge object for communication with UI</dd>
			<dt>{seq, forge} [x] (userdata, userdata)</dt>
				<dd>pairs of atom sequence and atom forge objects, with x=[0, 1, 2, 4]</dd>
			<dt>c [x] (number)</dt>
				<dd>control port inputs, with x=[0, 1, 2, 4]</dd>
		</dl>

		<pre><code data-ref="callbacks-once">-- 'once' callback prototype for moony#a1xa1

function once(n, control, notify, seq, forge)
	-- here we will run logic once right after a code update

	-- send all-notes-off MIDI message on all channels
	for channel = 0x0, 0xf do
		forge:time(0):midi(MIDI.Controller | channel, MIDI.AllNotesOff)
	end
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="callbacks-stash">stash</h2>
		<p>When script code is reloaded, plugin state inside Lua virtual machine
		potentially is lost. In order to preserve state across a script code reload,
		arbitrary state can be serialized and parked in temporary memory.
		Such a temporary serialized state can later be deserialized via
		<a href="#callbacks-apply">apply</a>.</p>

		<p>The <b>stash</b> function is directly called before parsing and loading
		the new script code.</p>

		<dl>
			<dt class="func">function stash(forge)</dt>
			<dt>forge (userdata)</dt>
				<dd>atom forge object to serialize to</dd>
		</dl>

		<pre><code data-ref="callbacks-stash">-- 'stash' callback prototype

-- a simple flag
local myflag = true

function stash(forge)
	-- serialize single boolean flag
	forge:bool(myflag)
end

function apply(atom)
	assert(atom.type == Atom.Bool)

	-- deserialize single boolean flag
	myflag = atom.body
	assert(myflag == true)
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="callbacks-apply">apply</h2>
		<p>When script code is reloaded, plugin state inside Lua virtual machine
		potentially is lost. In order to preserve state across a script code reload,
		arbitrary state previously serialized by <a href="#callbacks-stash">stash</a>
		can be deserialized from temporary memory.</p>

		<p>The <b>apply</b> function is directly called after parsing and loading
		the new script code.</p>

		<dl>
			<dt class="func">function apply(atom)</dt>
			<dt>atom (userdata)</dt>
				<dd>atom object to deserialize from</dd>
		</dl>

		<pre><code data-ref="callbacks-apply">-- 'apply' callback prototype

-- table that holds active notes
local active_notes = {
	60, 64, 67, 72
}

function stash(forge)
	local tup = forge:tuple()

	-- serialize active notes to atom tuple
	for i, v in ipairs(active_notes) do
		tup:int(v)
	end

	tup:pop()
end

function apply(atom)
	assert(atom.type == Atom.Tuple)

	-- clear active notes table
	active_notes = {}

	-- deserialize active notes from atom tuple
	for i, v in atom:foreach() do
		assert(v.type == Atom.Int)

		active_notes[i] = v.body
	end

	assert(#active_notes == 4)
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="callbacks-save">save</h2>
		<p>The <b>save</b> function works analogously to <a href="#callbacks-stash">stash</a>,
		but instead of serializing to temporary memory before a script code reload,
		<b>save</b> serializes to disk upon a state save request issued by the host.</p>

		<p>State serialized to disk by <b>save</b> is preserved across plugin instantiations
		and truly is the same as a preset.</p>

		<dl>
			<dt class="func">function save(forge)</dt>
			<dt>forge (userdata)</dt>
				<dd>atom forge object to serialize to</dd>
		</dl>

		<pre><code data-ref="callbacks-save">-- 'save' callback prototype

local urn = HashMap('urn:moony:xzy')

-- state
local state = {
	[urn.foo] = {
		[RDFS.range] = Atom.Int,
		[RDF.value] = 12
	},
	[urn.bar] = {
		[RDFS.range] = Atom.Chunk,
		[RDF.value] = string.char(0x0, 0x1, 0x2)
	}
}

function save(forge)
	local obj = forge:object()

	-- serialize state to atom object
	for k, v in pairs(state) do
		obj:key(k):typed(v[RDFS.range], v[RDF.value])
	end

	obj:pop()
end

function restore(atom)
	assert(atom.type == Atom.Object)

	-- deserialize state from atom object
	for k, v in pairs(state) do
		local itm = atom[k]

		if itm then
			assert(itm.type == v[RDFS.range])
			assert(itm.body == v[RDF.value])

			v[RDF.value] = itm.body
		end
	end
end</code></pre>
		</div>

		<div class="api-section">
		<h2 id="callbacks-restore">restore</h2>
		<p>The <b>restore</b> function works analogously to <a href="#callbacks-apply">apply</a>,
		but instead of deserializing from temporary memory after a script code reload,
		<b>restore</b> deserializes from disk upon a state reload request issued by the host.</p>

		<dl>
			<dt class="func">function restore(atom)</dt>
			<dt>atom (userdata)</dt>
				<dd>atom object to deserialize from</dd>
		</dl>

		<pre><code data-ref="callbacks-restore">-- 'restore' callback prototype

local urn = HashMap('urn:moony:xyz')

-- 3D positional state
local state = {
	[urn.position] = { 0.2, 0.3, 0.9 },
	[urn.rotation] = { -math.pi, 0.0, math.pi/2 }
}

function save(forge)
	local obj = forge:object()

	-- serialize state to atom object
	for k, v in pairs(state) do
		for vec in obj:key(k):vector(Atom.Float):autopop() do
			for i, w in ipairs(v) do
				vec:float(w)
			end
		end
	end

	obj:pop()
end

function restore(atom)
	assert(atom.type == Atom.Object)

	-- deserialize state from atom object
	for k, v in pairs(state) do
		local itm = atom[k]

		if itm then
			assert(itm.type == Atom.Vector)
			assert(itm.childType == Atom.Float)

			state[k] = { itm:unpack() }
			assert(#state[k] == 3)
		end
	end
end</code></pre>
		</div>

		<div class="api-section">
		<h1 id="urid">Map &amp; Unmap</h1>
		<p>LV2 references objects and their properties by URIs, usually rather long,
		unique string identifiers. When comparing URIs, whole strings need to be
		compared, which is inefficient. In LV2, an URI thus can be mapped to a simple
		integer URID, greatly increasing efficiency of comparisons. Unmapping from
		URID to original URI is supported, too.</p>

		<p>Moony directly mirrors mapping and unmapping of the underlying low-level
		implementation, but additionally caches every newly queried URI or URID
		for faster lookup inside script code. Cached URIs and URIDs are preserved
		across script code updates.</p>
		</div>

		<div class="api-section">
		<h2 id="urid-map">Map</h2>
		<p>Map an URI to its corresponding URID. <b>Map</b> is a first-class Lua
		table acting as a cache for all queried URIDs and can also be called as
		function.</p>

		<dl>
			<dt class="func">Map:__call(URI) | Map(URI) | Map:__index(URI) | Map[URI]</dt>
			<dt>URI (string)</dt>
				<dd>URI to be mapped</dd>
			<dt class="ret">(integer)</dt>
				<dd>mapped URID</dd>
		</dl>

		<pre><code data-ref="urid-map">-- Map can be indexed or called as function

local prefix = 'http://example.com#'

local foo_urid = Map(prefix .. 'foo')
local bar_urid = Map[prefix .. 'bar']</code></pre>
		</div>

		<div class="api-section">
		<h2 id="urid-unmap">Unmap</h2>
		<p>Unmap an URID to its original URI. <b>Unmap</b> is a first-class Lua
		table acting as a cache for all queried URIs and can also be called as
		function.</p>

		<dl>
			<dt class="func">Unmap:__call(URID) | Unmap(URID) | Unmap:__index(URID) | Unmap[URID]</dt>
			<dt>URID (integer)</dt>
				<dd>URID to be unmapped</dd>
			<dt class="ret">(string)</dt>
				<dd>unmapped URI</dd>
		</dl>

		<pre><code data-ref="urid-unmap">-- Unmap can be indexed or called as function

local prefix = 'http://example.com#'

local foo_urid= Map(prefix .. 'foo')
local bar_urid = Map[prefix .. 'bar']

local foo_uri = Unmap(foo_urid)
local bar_uri = Unmap[bar_urid]

assert(prefix .. 'foo' == foo_uri)
assert(prefix .. 'bar' == bar_uri)</code></pre>
		</div>

		<div class="api-section">
		<h2 id="urid-hashmap">HashMap</h2>
		<p>A convenience wrapper and syntactic sugar around <a href="#urid-map">Map</a>.
		Simplifies creating multiple mappings which share a common URI prefix.</p>

		<p>Returns a table which can be queried by indexing with the URI postfix.
		The query is equivalent to a mapping of concatenated URI prefix and postfix.</p>

		<p>This is especially useful when dealing with custom properties and the
		<a href="#responder-state">StateResponder</a>.</p>

		<dl>
			<dt class="func">HashMap(prefix)</dt>
			<dt>prefix (string)</dt>
				<dd>prefix string to be appended to</dd>
			<dt class="ret">(table)</dt>
				<dd>HashMap table</dd>
		</dl>

		<pre><code data-ref="urid-hashmap">-- HashMap is a convenience wrapper over Map

local prefix = 'http://example.com#'
local hashmap = HashMap(prefix)

local bar_urid = Map[prefix .. 'bar']

assert(hashmap.bar == bar_urid)</code></pre>
		</div>

		<div class="api-section">
		<h2 id="urid-voicemap">VoiceMap</h2>
		<p>Returns a unique, non-colliding integer ID to be used in event messaging.
		Especially useful for <a href="#forge-patch">Patch</a> messages or custom
		event systems where there is a need to track event properties over space
		and time.</p>

		<dl>
			<dt class="func">VoiceMap()</dt>
			<dt class="ret">(integer)</dt>
				<dd>unique integer ID</dd>
		</dl>

		<pre><code data-ref="urid-voicemap">-- VoiceMap returns unique integer IDs

local cache = {}

for i = 1, 100 do
	local id = VoiceMap()

	assert(not cache[id])
	cache[id] = true
end</code></pre>
		</div>

	<!-- Forge -->
	<div class="api-section">
	<h1 id="forge">Forge</h1>
	<p>A forge object is used to serialize arbitrary complex atoms, both simple
	primitives and nested containers.</p>
	</div>

		<!-- Forge Primitive -->
		<div class="api-section">
		<h2 id="forge-primitive">Primitive</h2>
		<p>Atom types that contain single data as part of their body are referred to
		as primitives.</p>
		</div>

			<!-- Forge Bool -->
			<div class="api-section">
			<h3 id="forge-bool">Bool</h3>
			<p>Forge a boolean atom, e.g. of type Atom.Bool.</p>

			<dl>
				<dt class="func">forge:bool(value)</dt>
				<dt>value (boolean)</dt>
					<dd>boolean value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-bool">-- Forge Bool

function stash_tuple(forge)
	forge:bool(true)
	forge:bool(false)
end</code></pre>
			</div>

			<!-- Forge Int -->
			<div class="api-section">
			<h3 id="forge-int">Int</h3>
			<p>Forge an integer atom, e.g. of type Atom.Int.</p>

			<dl>
				<dt class="func">forge:int(value)</dt>
				<dt>value (integer)</dt>
					<dd>integer value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-int">-- Forge Int

function stash(forge)
	forge:int(12)
end</code></pre>
			</div>

			<!-- Forge Long -->
			<div class="api-section">
			<h3 id="forge-long">Long</h3>
			<p>Forge long integer atom, e.g. of type Atom.Long.</p>

			<dl>
				<dt class="func">forge:long(value)</dt>
				<dt>value (integer)</dt>
					<dd>integer value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-long">-- Forge Long

function stash(forge)
	forge:long(12)
end</code></pre>
			</div>

			<!-- Forge Float -->
			<div class="api-section">
			<h3 id="forge-float">Float</h3>
			<p>Forge single-precision float atom, e.g. of type Atom.Float.</p>

			<dl>
				<dt class="func">forge:float(value)</dt>
				<dt>value (number)</dt>
					<dd>number value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-float">-- Forge Float

function stash(forge)
	forge:float(12.5)
end</code></pre>
			</div>

			<!-- Forge Double -->
			<div class="api-section">
			<h3 id="forge-double">Double</h3>
			<p>Forge double-precision float atom, e.g. of type Atom.Double.</p>

			<dl>
				<dt class="func">forge:double(value)</dt>
				<dt>value (number)</dt>
					<dd>number value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-double">-- Forge Double

function stash(forge)
	forge:double(12.5)
end</code></pre>
			</div>

			<!-- Forge URID -->
			<div class="api-section">
			<h3 id="forge-urid">URID</h3>
			<p>Forge URID atom, e.g. of type Atom.URID.</p>

			<dl>
				<dt class="func">forge:urid(value)</dt>
				<dt>value (integer)</dt>
					<dd>URID value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-urid">-- Forge URID

local uri = 'urn:moony:xzy'
local urn = Map[uri]

function stash(forge)
	forge:urid(urn)
end</code></pre>
			</div>

			<!-- Forge URI -->
			<div class="api-section">
			<h3 id="forge-uri">URI</h3>
			<p>Forge URI atom, e.g. of type Atom.URI.</p>

			<dl>
				<dt class="func">forge:uri(value)</dt>
				<dt>value (string)</dt>
					<dd>URI value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-uri">-- Forge URI

local uri = 'urn:moony:xzy'

function stash(forge)
	forge:uri(uri)
end</code></pre>
			</div>

			<!-- Forge String -->
			<div class="api-section">
			<h3 id="forge-string">String</h3>
			<p>Forge string atom, e.g. of type Atom.String.</p>

			<dl>
				<dt class="func">forge:string(value)</dt>
				<dt>value (string)</dt>
					<dd>string value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-string">-- Forge String

function stash(forge)
	forge:string('hello world')
end</code></pre>
			</div>

			<!-- Forge Path -->
			<div class="api-section">
			<h3 id="forge-path">Path</h3>
			<p>Forge path atom, e.g. of type Atom.Path.</p>

			<dl>
				<dt class="func">forge:path(value)</dt>
				<dt>value (string)</dt>
					<dd>string value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-path">-- Forge Path

function stash(forge)
	forge:path('/tmp/xyz')
end</code></pre>
			</div>

			<!-- Forge Literal -->
			<div class="api-section">
			<h3 id="forge-literal">Literal</h3>
			<p>Forge literal atom, e.g. of type Atom.Literal.</p>

			<dl>
				<dt class="func">forge:literal(value, datatype=nil, language=nil)</dt>
				<dt>value (string)</dt>
					<dd>string value to forge</dd>
				<dt>datatype (integer)</dt>
					<dd>datatype of literal as integer URID, defaults to 0</dd>
				<dt>language (integer)</dt>
					<dd>language of literal as integer URID, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-literal">-- Forge Literal

local rus = Map['http://lexvo.org/id/iso639-3/rus'] -- Russian language

function stash_tuple(forge)
	forge:literal('902A7F', MIDI.MidiEvent) -- MIDI encoded as hexidecimal text
	forge:literal('Приве́т!', nil, rus) -- 'hello!'
end</code></pre>
			</div>

			<!-- Forge Chunk -->
			<div class="api-section">
			<h3 id="forge-chunk">Chunk</h3>
			<p>Forge chunk atom, e.g. of type Atom.Chunk.</p>

			<dl>
				<dt class="func">forge:chunk(value)</dt>
				<dt>value (string)</dt>
					<dd>byte string value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:chunk(value)</dt>
				<dt>value (table)</dt>
					<dd>table with individual values to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:chunk(...)</dt>
				<dt>... (integer)</dt>
					<dd>individual values to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-chunk">-- Forge Chunk

function stash_tuple(forge)
	forge:chunk(string.char(0x1, 0x2, 0x3))
	forge:chunk({0x1, 0x2, 0x3})
	forge:chunk(0x1, 0x2, 0x3)
end</code></pre>
			</div>

			<!-- Forge MIDI -->
			<div class="api-section">
			<h3 id="forge-midi">MIDI</h3>
			<p>Forge MIDI atom, e.g. of type MIDI.MidiEvent.</p>

			<dl>
				<dt class="func">forge:midi(value)</dt>
				<dt>value (string)</dt>
					<dd>byte string value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:midi(value)</dt>
				<dt>value (table)</dt>
					<dd>table with individual values to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:midi(...)</dt>
				<dt>... (integer)</dt>
					<dd>individual values to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-midi">-- Forge MIDI

function stash_tuple(forge)
	forge:midi(string.char(MIDI.NoteOn, 69, 0x7f))
	forge:midi({MIDI.NoteOn, 69, 0x7f})
	forge:midi(MIDI.NoteOn, 69, 0x7f)
end</code></pre>
			</div>

			<!-- Forge Raw -->
			<div class="api-section">
			<h3 id="forge-raw">Raw</h3>
			<p>Forge a custom atom of arbitrary type.</p>

			<dl>
				<dt class="func">forge:raw(type, value)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>value (string)</dt>
					<dd>byte string value to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:raw(type, value)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>value (table)</dt>
					<dd>table with individual values to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<dl>
				<dt class="func">forge:raw(type, ...)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>... (integer)</dt>
					<dd>individual values to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-raw">-- Forge Raw

local byt = { -- stores individual bytes of zero-terminated string 'LV2'
	string.byte('L'),
	string.byte('V'),
	string.byte('2'),
	string.byte('\0')
}

function stash_tuple(forge)
	forge:raw(Atom.String, string.char(table.unpack(byt)))
	forge:raw(Atom.String, byt)
	forge:raw(Atom.String, table.unpack(byt))
end</code></pre>
			</div>

			<!-- Forge Typed -->
			<div class="api-section">
			<h3 id="forge-typed">Typed</h3>
			<p>Forge an atom of arbitrary type.</p>

			<dl>
				<dt class="func">forge:typed(type, ...)</dt>
				<dt>type (integer)</dt>
					<dd>type of atom as integer URID</dd>
				<dt>... (boolean | integer | number | string | table)</dt>
					<dd>value(s) to forge, see native forge functions documentation</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-typed">-- Forge Typed

function stash_tuple(forge)
	forge:typed(Atom.Int, 12) -- equivalent to forge:int(...)
	forge:typed(Atom.Float, 12.5) -- equivalent to forge:float(...)
	forge:typed(Atom.String, 'LV2 rocks!') -- equivalent to forge:string(...)
end</code></pre>
			</div>

			<!-- Forge Atom -->
			<div class="api-section">
			<h3 id="forge-atom">Atom</h3>
			<p>Forge an unchanged atom. Useful for cloning whole atoms.</p>

			<dl>
				<dt class="func">forge:atom(value)</dt>
				<dt>value (userdata)</dt>
					<dd>atom to forge</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-atom">-- Forge Atom

-- forge integer atom
function stash_tuple(forge)
	forge:int(12)
end

-- forge prepared integer atom in whole
function apply_tuple(tup, forge)
	assert(tup[1].body == 12)

	forge:atom(tup[1])
end

-- check if integer atom has been forged in whole
function check(tup)
	assert(tup[1].body == 12)
end</code></pre>
			</div>

		<!-- Forge Container -->
		<div class="api-section">
		<h2 id="forge-container">Container</h2>
		<p>Atom types that contain nested atoms as part of their body are referred to
		as containers.</p>
		</div>

			<!-- Forge Sequence -->
			<div class="api-section">
			<h3 id="forge-sequence">Sequence</h3>
			<p>Forge a sequence atom, e.g. an atom of type Atom.Sequence.</p>

			<dl>
				<dt class="func">forge:sequence(unit=0)</dt>
				<dt>unit (integer)</dt>
					<dd>event time unit as integer URID, defaults to 0, can either be Atom.frameTime or Atom.beatTime</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-sequence">-- Forge Sequence

function stash_tuple(forge)
	local seq = forge:sequence() -- create derived container forge object
		seq:time(0):int(12)
		seq:frameTime(1):int(13)
	seq:pop() -- finalize container

	seq = forge:sequence(Atom.frameTime) -- create derived container forge object
		seq:time(0):int(12)
		seq:frameTime(1):int(13)
	seq:pop() -- finalize container

	for seq in forge:sequence(Atom.beatTime):autopop() do -- create iterator for derived container forge object
		seq:time(0.0):int(12)
		seq:beatTime(1.0):int(13)
	end -- finalize container
end</code></pre>
			</div>

				<!-- Forge Frame Time-->
				<div class="api-section">
				<h4 id="forge-frame-time">Frame Time</h4>
				<p>Forge frame time of event. Use this on sequences with unit 0 or Atom.frameTime.</p>

				<dl>
					<dt class="func">forge:frameTime(frames)</dt>
					<dt>frames (integer)</dt>
						<dd>frame time of event</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

				<!-- Forge Beat Time-->
				<div class="api-section">
				<h4 id="forge-beat-time">Beat Time</h4>
				<p>Forge beat time of event. Use this on sequences with unit Atom.beatTime.</p>

				<dl>
					<dt class="func">forge:beatTime(beats)</dt>
					<dt>beats (number)</dt>
						<dd>beat time of event</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

				<!-- Forge Time-->
				<div class="api-section">
				<h4 id="forge-time">Time</h4>
				<p>Forge frame or beat time of event. Can be used as syntactic sugar instead of
				<a href="#forge-frame-time">Frame Time</a> or <a href="#forge-beat-time">Beat Time</a>.</p>

				<dl>
					<dt class="func">forge:time(timestamp)</dt>
					<dt>timestamp (integer | number)</dt>
						<dd>frame time (integer) or beat time (number) of event</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

			<!-- Forge Object -->
			<div class="api-section">
			<h3 id="forge-object">Object</h3>
			<p>Forge an object atom, e.g. an atom of type Atom.Object.</p>

			<dl>
				<dt class="func">forge:object(otype=0, id=0)</dt>
				<dt>otype (integer)</dt>
					<dd>object type as integer URID, defaults to 0</dd>
				<dt>id (integer)</dt>
					<dd>object ID as integer URID, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-object">-- Forge Object
local urn = HashMap('urn:moony:xyz')

function stash_tuple(forge)
	local obj = forge:object(urn.FooBar) -- create derived container forge object
		obj:key(urn.foo):int(12) -- without context
		obj:key(urn.bar, urn.ctx):long(13) -- with context
	obj:pop() -- finalize container

	for obj in forge:object(urn.FooBar):autopop() do -- create iterator for derived container forge object
		obj:key(urn.foo):int(12) -- without context
		obj:key(urn.bar, urn.ctx):long(13) -- with context
	end -- finalize container
end</code></pre>
			</div>

				<!-- Forge Key -->
				<div class="api-section">
				<h4 id="forge-key">Key</h4>
				<p>Forge key of object property.</p>

				<dl>
					<dt class="func">forge:key(value, context=0)</dt>
					<dt>value (integer)</dt>
						<dd>key of property as integer URID</dd>
					<dt>context (integer)</dt>
						<dd>context of property as integer URID, defaults to 0</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

			<!-- Forge Tuple -->
			<div class="api-section">
			<h3 id="forge-tuple">Tuple</h3>
			<p>Forge a tuple atom, e.g. an atom of type Atom.Tuple.</p>

			<dl>
				<dt class="func">forge:tuple()</dt>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-key">-- Forge Tuple

function stash_tuple(forge)
	local tup = forge:tuple() -- create derived container forge object
		tup:int(12)
		tup:long(13)
		tup:float(13.5)
		tup:double(14.5)
		tup:string('this is an element of an atom tuple')
		tup:bool(true)
	tup:pop() -- finalize container

	for tup in forge:tuple():autopop() do -- create iterator for derived container forge object
		tup:int(12)
		tup:long(13)
		tup:float(13.5)
		tup:double(14.5)
		tup:string('this is an element of an atom tuple')
		tup:bool(true)
	end -- finalize container
end</code></pre>
			</div>

			<!-- Forge Vector -->
			<div class="api-section">
			<h3 id="forge-vector">Vector</h3>
			<p>Forge a vector atom, e.g. an atom of type Atom.Vector.</p>

			<dl>
				<dt class="func">forge:vector(type)</dt>
					<dt>type (integer)</dt>
						<dd>child type as integer URID, valid are: Atom.Bool, Atom.Int, Atom.Float, Atom.Long, Atom.Double, Atom.URID</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-vector">-- Forge Vector

local vBool = {
	true, false, true
}

function stash_tuple(forge)
	forge:vector(Atom.Int):int(1):int(2):int(3):int(4):int(5):pop()

	for vec in forge:vector(Atom.Bool):autopop() do
		for i, v in ipairs(vBool) do
			vec:bool(v)
		end
	end
end</code></pre>
			</div>

			<!-- Forge Pop -->
			<div class="api-section">
			<h3 id="forge-pop">Pop</h3>
			<p>Finalize any derived container forge object.</p>

			<dl>
				<dt class="func">forge:pop()</dt>
				<dt class="ret">(userdata)</dt>
					<dd>parent container forge object</dd>
			</dl>

			<pre><code data-ref="forge-pop">-- Pop

function stash(forge)
	local tup = forge:tuple()
	tup:int(1)
	tup:int(2)
	tup:pop()
end

function apply(atom)
	assert(#atom == 2)
end</code></pre>
			</div>

			<!-- Forge AutoPop -->
			<div class="api-section">
			<h3 id="forge-autopop">Autopop</h3>
			<p>Finalize any derived container forge object automatically via a for-iterator-construction.</p>

			<dl>
				<dt class="func">forge:autopop()</dt>
				<dt class="ret">(function, userdata)</dt>
					<dd>iterator function, parent container forge object</dd>
			</dl>

			<pre><code data-ref="forge-autopop">-- Autopop

function stash(forge)
	for tup in forge:tuple():autopop() do
		tup:int(1)
		tup:int(2)
	end
end

function apply(atom)
	assert(#atom == 2)
end</code></pre>
			</div>

		<!-- Forge OSC -->
		<div class="api-section">
		<h2 id="forge-osc">OSC</h2>
		<p>Atom types that contain Open Sound Control bundles or messages as part of their body.</p>
		</div>

			<!-- Forge Bundle -->
			<div class="api-section">
			<h3 id="forge-bundle">Bundle</h3>
			<p>Forge a OSC bundle atom, e.g. an atom object of type OSC.Bundle.</p>

			<dl>
				<dt class="func">forge:bundle(timestamp=1)</dt>
				<dt>timestamp (integer | number)</dt>
					<dd>absolute timestamp in frames (integer) or relative timestamp (number) in seconds, defaults to 1 aka immediate</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-bundle">-- Forge Bundle

function stash_tuple(forge)
	-- schedule bundle for immediate dispatch
	local bndl = forge:bundle() -- create derived container forge object
		bndl:message('/hello', 's', 'world')
	bndl:pop() -- finalize container

	-- schedule bundle for dispatch @ Sep 19, 2016 02.09.16.015811000 UTC
	bndl = forge:bundle(0xdb89c74c040c3199)
		bndl:message('/hello', 's', 'world')
	bndl:pop()

	-- schedule bundle for dispatch in 0.1s
	bndl = forge:bundle(0.1)
		bndl:message('/hello', 's', 'world')
	bndl:pop()
end</code></pre>
			</div>

			<!-- Forge Message -->
			<div class="api-section">
			<h3 id="forge-message">Message</h3>
			<p>Forge a OSC message atom, e.g. an atom object of type OSC.Message.
			Supported OSC argument types are: 'i', 'f', 's', 'b', 'h', 'd', 't',
			'm', 'S', 'c', 'r', 'T', 'F', 'N', 'I'</p>

			<dl>
				<dt class="func">forge:message(path, format, ...)</dt>
				<dt>path (string)</dt>
					<dd>OSC path as string</dd>
				<dt>format (string)</dt>
					<dd>OSC format as string</dd>
				<dt>... (integer | number | string)</dt>
					<dd>variable arguments according to format</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-message">-- Forge Message

function stash(forge)
	-- schedule bundle for immediate dispatch
	local bndl = forge:bundle() -- create derived container forge object
		bndl:message('/hello', 'ifs', 2016, 12.5, 'hello')
		bndl:message('/hello', 'b', string.char(0x1, 0x2, 0x3))
		bndl:message('/hello', 'hdS', 2017, 13.5, 'world')
		bndl:message('/hello', 't', 0xdb89c74c040c3199)
		bndl:message('/hello', 'TFNI')
		bndl:message('/hello', 'm', string.char(MIDI.NoteOn, 69, 0x7f))
		bndl:message('/hello', 'cr', string.byte('s'), 0xff00ff00)
	bndl:pop() -- finalize container)
end</code></pre>
			</div>

				<!-- Forge Impulse -->
				<div class="api-section">
				<h4 id="forge-impulse">Impulse</h4>
				<p>Forge Impulse argument of OSC message.</p>

				<dl>
					<dt class="func">forge:impulse()</dt>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

				<!-- Forge Char -->
				<div class="api-section">
				<h4 id="forge-char">Char</h4>
				<p>Forge Char argument of OSC message.</p>

				<dl>
					<dt class="func">forge:char(ch)</dt>
					<dt>ch (integer)</dt>
						<dd>character as integer</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

				<!-- Forge RGBA -->
				<div class="api-section">
				<h4 id="forge-rgba">RGBA</h4>
				<p>Forge RGBA color argument of OSC message.</p>

				<dl>
					<dt class="func">forge:rgba(col)</dt>
					<dt>col (integer)</dt>
						<dd>color as 32-bit unsigned integer</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>
				</div>

				<!-- Forge Timetag -->
				<div class="api-section">
				<h4 id="forge-timetag">Timetag</h4>
				<p>Forge Timetag argument of OSC message.</p>

				<dl>
					<dt class="func">forge:timetag(timestamp)</dt>
					<dt>timestamp (integer | number)</dt>
						<dd>absolute timestamp in frames (integer) or relative timestamp (number) in seconds, defaults to 1 aka immediate</dd>
					<dt class="ret">(userdata)</dt>
						<dd>self forge object</dd>
				</dl>

				<pre><code data-ref="forge-timetag">-- Forge custom OSC arguments

function stash(forge)
	for obj in forge:object(OSC.Message):autopop() do
		obj:key(OSC.messagePath):string('/custom')
		for tup in obj:key(OSC.messageArguments):tuple():autopop() do
			-- forge 'i', 'f', 's', 'b' OSC arguments
			tup:int(12) -- 'i'nteger
			tup:float(1.5) -- 'f'loat
			tup:string('foo') -- 's'tring
			tup:chunk(string.char(0x1, 0x2)) -- 'b'lob

			-- forge 'h', 'd', 't' OSC arguments
			tup:long(13) -- 'h'
			tup:double(1.6) -- 'd'ouble
			tup:timetag(0.1) -- 't', 100ms from now

			-- forge 'N', 'I', 'T', 'F' OSC arguments
			tup:raw(0) -- empty atom, 'N'il
			tup:impulse() -- 'I'mpulse
			tup:bool(true) -- 'T'rue
			tup:bool(false) -- 'F'alse

			-- forge 'c', 'r', 'm', 'S' OSC arguments
			tup:char(string.byte('c')) -- 'c'char
			tup:rgba(0xbb0000ff) -- reddish, 'r'gba
			tup:midi(MIDI.NoteOn, Note['C-0'], 64) -- 'm'idi
			tup:urid(Param.sampleRate) -- 'S'ymbol
		end
	end
end</code></pre>
				</div>

		<!-- Forge Patch -->
		<div class="api-section">
		<h2 id="forge-patch-patch">Patch</h2>
		<p>Atom types that contain Patch messages as part of their body.</p>
		</div>

			<!-- Forge Patch-->
			<div class="api-section">
			<h3 id="forge-patch">Patch</h3>
			<p>Forge a patch patch atom, e.g. an atom object of type Patch.Patch.</p>

			<dl>
				<dt class="func">forge:patch(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-patch">-- Forge Patch

local urn = HashMap('urn:moony:xzy')

function stash(forge)
	local patch= forge:patch(urn.subj, 1002) -- with subject and sequence number

		local rem = patch:remove() -- equivalent to patch:object(Patch.remove)
			rem:key(urn.foo):urid(Patch.wildcard)
			rem:key(urn.bar):urid(Patch.wildcard)
		rem:pop()

		local add = patch:add() -- equivalent to patch:object(Patch.add)
			add:key(urn.foo):int(12)
			add:key(urn.bar):float(12.5)
		add:pop()

	patch:pop()
end</code></pre>
			</div>

				<!-- Forge Add -->
				<div class="api-section">
				<h4 id="forge-add">Add</h4>
				<p>Forge add property of patch property.</p>

				<dl>
					<dt class="func">forge:add()</dt>
					<dt class="ret">(userdata)</dt>
						<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
				</dl>
				</div>

				<!-- Forge Add -->
				<div class="api-section">
				<h4 id="forge-remove">Remove</h4>
				<p>Forge remove property of patch property.</p>

				<dl>
					<dt class="func">forge:remove()</dt>
					<dt class="ret">(userdata)</dt>
						<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
				</dl>
				</div>

			<!-- Forge Get -->
			<div class="api-section">
			<h3 id="forge-get">Get</h3>
			<p>Forge a patch get atom, e.g. an atom object of type Patch.Get.</p>

			<dl>
				<dt class="func">forge:get(property, subject=0, sequenceNumber=0)</dt>
				<dt>property (integer)</dt>
					<dd>patch property as integer URID</dd>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self container object</dd>
			</dl>

			<pre><code data-ref="forge-get">-- Forge Get

local urn = HashMap('urn:moony:xzy')

function stash_tuple(forge)
	forge:get(urn.prop) -- without subject and sequence number
	forge:get(urn.prop, nil, 1001) -- without subject
	forge:get(urn.prop, urn.subj, 1002) -- with subject and sequence number
end</code></pre>
			</div>

			<!-- Forge Set -->
			<div class="api-section">
			<h3 id="forge-set">Set</h3>
			<p>Forge a patch set atom, e.g. an atom object of type Patch.Set.</p>

			<dl>
				<dt class="func">forge:set(property, subject=0, sequenceNumber=0)</dt>
				<dt>property (integer)</dt>
					<dd>patch property as integer URID</dd>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-set">-- Forge Set

local urn = HashMap('urn:moony:xzy')

function stash_tuple(forge)
	local set = forge:set(urn.prop) -- without subject and sequence number
		set:int(12)
	set:pop()

	set = forge:set(urn.prop, urn.subj, 1002) -- with subject and sequence number
		set:float(12)
	set:pop()
end</code></pre>
			</div>

			<!-- Forge Put -->
			<div class="api-section">
			<h3 id="forge-put">Put</h3>
			<p>Forge a patch put atom, e.g. an atom object of type Patch.Put.</p>

			<dl>
				<dt class="func">forge:put(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>derived container forge object, needs to be finalized with <a href="#forge-pop">Pop</a></dd>
			</dl>

			<pre><code data-ref="forge-put">-- Forge Put

local urn = HashMap('urn:moony:xzy')

function stash_tuple(forge)
	local put = forge:put() -- without subject and sequence number
		put:key(urn.foo):int(12)
		put:key(urn.bar):float(12.5)
	put:pop()

	put= forge:put(urn.subj, 1002) -- with subject and sequence number
		put:key(urn.foo):int(12)
		put:key(urn.bar):float(12.5)
	put:pop()
end</code></pre>
			</div>

			<!-- Forge Ack -->
			<div class="api-section">
			<h3 id="forge-ack">Ack</h3>
			<p>Forge an ack patch atom, e.g. an atom object of type Patch.Ack.</p>

			<dl>
				<dt class="func">forge:ack(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-ack">-- Forge Ack

local urn = HashMap('urn:moony:xzy')

function stash(forge)
	forge:ack(urn.subj, 1002) -- with subject and sequence number
end</code></pre>
			</div>

			<!-- Forge Error -->
			<div class="api-section">
			<h3 id="forge-error">Error</h3>
			<p>Forge an error patch atom, e.g. an atom object of type Patch.Error.</p>

			<dl>
				<dt class="func">forge:error(subject=0, sequenceNumber=0)</dt>
				<dt>subject (integer)</dt>
					<dd>patch subject as integer URID, defaults to 0</dd>
				<dt>sequenceNumber (integer)</dt>
					<dd>patch sequence number as integer, defaults to 0</dd>
				<dt class="ret">(userdata)</dt>
					<dd>self forge object</dd>
			</dl>

			<pre><code data-ref="forge-error">-- Forge Error

local urn = HashMap('urn:moony:xzy')

function stash(forge)
	forge:error(urn.subj, 1002) -- with subject and sequence number
end</code></pre>
			</div>

	<div class="api-section">
	<h1 id="atom">Atom</h1>
	<p>Instead of deserializing all LV2 event data to corresponding Lua types,
	Moony instead presents a proxy object to the user in form of a Lua userdata.
	This is needed because there are more LV2 atom types than native Lua types.
	It turns out to be more efficient, too, as the user usually wants to filter
	events before looking at their payload.</p>

	<p>All atom types have some common attributes they can be queried for:</p>

	<dl>
		<dt class="attr">atom.__len | #atom</dt>
		<dt class="ret">(integer)</dt>
			<dd>size of atom body</dd>
	</dl>

	<dl>
		<dt class="attr">atom.__tostring | tostring(atom)</dt>
		<dt class="ret">(string)</dt>
			<dd>string representation of atom</dd>
	</dl>

	<dl>
		<dt class="attr">atom.type</dt>
		<dt class="ret">(integer)</dt>
			<dd>URID of atom type</dd>
	</dl>

	<dl>
		<dt class="attr">atom.raw</dt>
		<dt class="ret">(string)</dt>
			<dd>raw byte string of atom body</dd>
	</dl>
	</div>

		<!-- Atom Primitive -->
		<div class="api-section">
		<h2 id="atom-primitive">Primitive</h2>
		<p>Atom types that contain single data as part of their body are referred to
		as primitives.</p>
		</div>

			<!-- Atom Nil -->
			<div class="api-section">
			<h3 id="atom-nil">Nil</h3>
			<p>An empty atom, e.g. of type and size 0.</p>

			<dl>
				<dt class="attr">nil.__len | #nil</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">nil.__tostring | tostring(nil)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">nil.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">nil.body</dt>
				<dt class="ret">(nil)</dt>
					<dd>atom body as Lua nil</dd>
			</dl>

			<pre><code data-ref="atom-nil">-- Atom Nil

-- serialize
function stash(forge)
end

function apply(atom)
	-- attributes
	assert(#atom == 0) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == 0) -- query type of atom
	assert(atom.body == nil) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Bool -->
			<div class="api-section">
			<h3 id="atom-bool">Bool</h3>
			<p>A boolean atom, e.g. of type Atom.Bool and size 4.</p>

			<dl>
				<dt class="attr">bool.__len | #bool</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">bool.__tostring | tostring(bool)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">bool.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">bool.body</dt>
				<dt class="ret">(boolean)</dt>
					<dd>atom body as Lua boolean</dd>
			</dl>

			<pre><code data-ref="atom-bool">-- Atom Bool

-- serialize
function stash(forge)
	forge:bool(true)
end

function apply(atom)
	-- attributes
	assert(#atom == 4) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Bool) -- query type of atom
	assert(atom.body == true) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Int -->
			<div class="api-section">
			<h3 id="atom-int">Int</h3>
			<p>An integer atom, e.g. of type Atom.Int and size 4.</p>

			<dl>
				<dt class="attr">int.__len | #int</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">int.__tostring | tostring(int)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">int.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">int.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom body as Lua integer</dd>
			</dl>

			<pre><code data-ref="atom-int">-- Atom Int

-- serialize
function stash(forge)
	forge:int(12)
end

function apply(atom)
	-- attributes
	assert(#atom == 4) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Int) -- query type of atom
	assert(atom.body == 12) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Long -->
			<div class="api-section">
			<h3 id="atom-long">Long</h3>
			<p>A long integer atom, e.g. of type Atom.Long and size 8.</p>

			<dl>
				<dt class="attr">long.__len | #long</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">long.__tostring | tostring(long)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">long.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">long.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom body as Lua integer</dd>
			</dl>

			<pre><code data-ref="atom-long">-- Atom Long

-- serialize
function stash(forge)
	forge:long(13)
end

function apply(atom)
	-- attributes
	assert(#atom == 8) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Long) -- query type of atom
	assert(atom.body == 13) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Float -->
			<div class="api-section">
			<h3 id="atom-float">Float</h3>
			<p>A single-precision float atom, e.g. of type Atom.Float and size 4.</p>

			<dl>
				<dt class="attr">float.__len | #float</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">float.__tostring | tostring(float)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">float.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">float.body</dt>
				<dt class="ret">(number)</dt>
					<dd>atom body as Lua number</dd>
			</dl>

			<pre><code data-ref="atom-float">-- Atom Float

-- serialize
function stash(forge)
	forge:float(1.5)
end

function apply(atom)
	-- attributes
	assert(#atom == 4) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Float) -- query type of atom
	assert(atom.body == 1.5) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Double -->
			<div class="api-section">
			<h3 id="atom-double">Double</h3>
			<p>A double-precision float atom, e.g. of type Atom.Double and size 8.</p>

			<dl>
				<dt class="attr">double.__len | #double</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">double.__tostring | tostring(double)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">double.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">double.body</dt>
				<dt class="ret">(number)</dt>
					<dd>atom body as Lua number</dd>
			</dl>

			<pre><code data-ref="atom-double">-- Atom Double

-- serialize
function stash(forge)
	forge:double(1.6)
end

function apply(atom)
	-- attributes
	assert(#atom == 8) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Double) -- query type of atom
	assert(atom.body == 1.6) -- get atom body
end</code></pre>
			</div>

			<!-- Atom URID -->
			<div class="api-section">
			<h3 id="atom-urid">URID</h3>
			<p>An URID atom, e.g. of type Atom.URID and size 4.</p>

			<dl>
				<dt class="attr">urid.__len | #urid</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">urid.__tostring | tostring(urid)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">urid.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">urid.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom body as Lua integer</dd>
			</dl>

			<pre><code data-ref="atom-urid">-- Atom URID

local urn = Map['urn:moony:xyz']

-- serialize
function stash(forge)
	forge:urid(urn)
end

function apply(atom)
	-- attributes
	assert(#atom == 4) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.URID) -- query type of atom
	assert(atom.body == urn) -- get atom body
end</code></pre>
			</div>

			<!-- Atom URI -->
			<div class="api-section">
			<h3 id="atom-uri">URI</h3>
			<p>An URI atom, e.g. of type Atom.URI and variable size. Atom size
			denotes to string size plus zero byte terminator.</p>

			<dl>
				<dt class="attr">uri.__len | #uri</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">uri.__tostring | tostring(uri)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">uri.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">uri.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<pre><code data-ref="atom-uri">-- Atom URI

local urn = 'urn:moony:xyz'

-- serialize
function stash(forge)
	forge:uri(urn)
end

function apply(atom)
	-- attributes
	assert(#atom == #urn + 1) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.URI) -- query type of atom
	assert(atom.body == urn) -- get atom body
end</code></pre>
			</div>

			<!-- Atom String -->
			<div class="api-section">
			<h3 id="atom-string">String</h3>
			<p>A string atom, e.g. of type Atom.String and variable size. Atom size
			denotes to string size plus zero byte terminator.</p>

			<dl>
				<dt class="attr">string.__len | #string</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">string.__tostring | tostring(string)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">string.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">string.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<pre><code data-ref="atom-string">-- Atom String

local str = 'hello world'

-- serialize
function stash(forge)
	forge:string(str)
end

function apply(atom)
	-- attributes
	assert(#atom == #str + 1) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.String) -- query type of atom
	assert(atom.body == str) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Path -->
			<div class="api-section">
			<h3 id="atom-path">Path</h3>
			<p>A path atom, e.g. of type Atom.Path and variable size. Atom size
			denotes to string size plus zero byte terminator.</p>

			<dl>
				<dt class="attr">path.__len | #path</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">path.__tostring | tostring(path)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">path.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">path.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<pre><code data-ref="atom-path">-- Atom Path

local tmp = '/tmp/xyz'

-- serialize
function stash(forge)
	forge:path(tmp)
end

function apply(atom)
	-- attributes
	assert(#atom == #tmp + 1) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Path) -- query type of atom
	assert(atom.body == tmp) -- get atom body
end</code></pre>
			</div>

			<!-- Atom Literal -->
			<div class="api-section">
			<h3 id="atom-literal">Literal</h3>
			<p>A literal atom, e.g. of type Atom.Literal and variable size. Atom size
			denotes to string size plus zero byte terminator. Atom literals may have
			either a data type or language attribute.</p>

			<dl>
				<dt class="attr">literal.__len | #literal</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">literal.__tostring | tostring(literal)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">literal.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">literal.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua string</dd>
			</dl>

			<dl>
				<dt class="attr">literal.datatype</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of data type</dd>
			</dl>

			<dl>
				<dt class="attr">literal.body</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of language</dd>
			</dl>

			<dl>
				<dt class="func">literal:unpack()</dt>
				<dt class="ret">(string, integer, integer)</dt>
					<dd>atom body as Lua string, URID of data type, URID of language</dd>
			</dl>

			<pre><code data-ref="atom-literal">-- Atom  Literal

local lit = 'Hallo Welt'
local datatype = Map['urn:moony:xyz']
local lang = Map['urn:moony:de']

-- serialize
function stash(forge)
	forge:literal(lit, datatype, lang)
end

function apply(atom)
	-- attributes
	assert(#atom == 4 + 4 + #lit + 1) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Literal) -- query type of atom
	assert(atom.datatype == datatype) -- query datatype of literal
	assert(atom.lang == lang) -- query datatype of literal
	assert(atom.body == lit) -- get atom body

	-- unpacking all attributes
	local lit2, datatype2, lang2 = atom:unpack()
	assert(lit2 == lit)
	assert(datatype2 == datatype)
	assert(lang2 == lang)
end</code></pre>
			</div>

			<!-- Atom Chunk-->
			<div class="api-section">
			<h3 id="atom-chunk">Chunk</h3>
			<p>A chunk atom, e.g. of type Atom.Chunk and variable size. Atom size
			denotes to byte size of atom body.</p>

			<dl>
				<dt class="attr">chunk.__len | #chunk</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">chunk.__tostring | tostring(chunk)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">chunk.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">chunk.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua byte string</dd>
			</dl>

			<dl>
				<dt class="func">chunk:unpack(from=1, to=#chunk)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start byte position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end byte position to unpack from, defaults to body size<dd>
				<dt class="ret">(integer, integer, ...)</dt>
					<dd>atom body unpacked bytewise as Lua integers</dd>
			</dl>

			<dl>
				<dt class="func">chunk:__index(idx) | chunk[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>byte position to query for</dd>
				<dt class="ret">(integer)</dt>
					<dd>byte at position idx of atom body as Lua integer</dd>
			</dl>

			<pre><code data-ref="atom-chunk">-- Atom Chunk

local byt = string.char(0x1, 0x2, 0x3)

-- serialize
function stash(forge)
	forge:chunk(byt)
end

function apply(atom)
	-- attributes
	assert(#atom == #byt) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == Atom.Chunk) -- query type of atom
	assert(atom.body == byt) -- get atom body

	-- unpacking all bytes
	local byt1, byt2, byt3 = atom:unpack() -- equivalent to atom:unpack(1, #atom)
	assert(byt1 == 0x1)
	assert(byt2 == 0x2)
	assert(byt3 == 0x3)

	-- indexing individual bytes
	assert(atom[1] == 0x1)
	assert(atom[2] == 0x2)
	assert(atom[3] == 0x3)
end</code></pre>
			</div>

			<!-- Atom MIDI -->
			<div class="api-section">
			<h3 id="atom-midi">MIDI</h3>
			<p>A MIDI atom, e.g. of type MIDI.MidiEvent and variable size. Atom size
			denotes to byte size of atom body. A MIDI atom is an equivalent to a
			Chunk atom and thus features the same class attributes and methods.</p>

			<dl>
				<dt class="attr">midi.__len | #midi</dt>
				<dt class="ret">(integer)</dt>
					<dd>size of atom body</dd>
			</dl>

			<dl>
				<dt class="attr">midi.__tostring | tostring(midi)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">midi.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">midi.body</dt>
				<dt class="ret">(string)</dt>
					<dd>atom body as Lua byte string</dd>
			</dl>

			<dl>
				<dt class="func">midi:unpack(from=1, to=#midi)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start byte position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end byte position to unpack from, defaults to body size<dd>
				<dt class="ret">(integer, integer, ...)</dt>
					<dd>atom body unpacked bytewise as Lua integers</dd>
			</dl>

			<dl>
				<dt class="func">midi:__index(idx) | midi[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>byte position to query for</dd>
				<dt class="ret">(integer)</dt>
					<dd>byte at position idx of atom body as Lua integer</dd>
			</dl>

			<pre><code data-ref="atom-midi">-- Atom MIDI

local byt = string.char(MIDI.NoteOn, 69, 64)

-- serialize
function stash(forge)
	forge:midi(byt)
end

function apply(atom)
	-- attributes
	assert(#atom == #byt) -- query size of atom body
	print(tostring(atom)) -- convert to string
	assert(atom.type == MIDI.MidiEvent) -- query type of atom
	assert(atom.body == byt) -- get atom body

	-- unpack all bytes
	local byt1, byt2, byt3 = atom:unpack() -- equivalent to atom:unpack(1, #atom)
	assert(byt1 == MIDI.NoteOn)
	assert(byt2 == 69)
	assert(byt3 == 64)

	-- indexing individual bytes
	assert(atom[1] == MIDI.NoteOn)
	assert(atom[2] == 69)
	assert(atom[3] == 64)
end</code></pre>
			</div>

		<div class="api-section">
		<h2 id="atom-container">Container</h2>
		<p>Atom types that contain nested atoms as part of their body are referred to
		as containers.</p>
		</div>

			<!-- Atom Sequence -->
			<div class="api-section">
			<h3 id="atom-sequence">Sequence</h3>
			<p>A Sequence atom, e.g. of type Atom.Sequence and variable size. Atom size
			denotes to number of events contained in atom body. An atom sequence
			consists of individual atom events, each with a time stamp and event
			pyaload.</p>

			<dl>
				<dt class="attr">seq.__len | #seq</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of events</dd>
			</dl>

			<dl>
				<dt class="attr">seq.__tostring | tostring(seq)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">seq.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">seq.unit</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of event time unit</dd>
			</dl>

			<dl>
				<dt class="func">seq:foreach()</dt>
				<dt class="ret">(integer | number, userdata)</dt>
					<dd>iterates over all atom events returning frame or beat time and event atom.</dd>
			</dl>

			<dl>
				<dt class="func">seq:foreach(...)</dt>
				<dt>... (userdata)</dt>
					<dd>additional sequence(s) to multiplex and iterate over.</dd>
				<dt class="ret">(integer | number, userdata, userdata)</dt>
					<dd>multiplexes and iterates over all atom events from all sequences returning frame or beat time, event atom and source sequence atom.</dd>
			</dl>

			<dl>
				<dt class="func">seq:__index(idx) | seq[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>event position to query for</dd>
				<dt class="ret">(userdata)</dt>
					<dd>event atom at position idx</dd>
			</dl>

			<pre><code data-ref="atom-sequence">-- Atom Sequence

-- serialize
function stash(forge)
	local seq = forge:sequence(Atom.frameTime)
		seq:time(0):int(12)
	seq:pop()
end

function apply(seq)
	-- attributes
	assert(#seq == 1) -- query number of events
	print(tostring(seq)) -- convert to string
	assert(seq.type == Atom.Sequence) -- query type of atom
	assert(seq.unit == Atom.frameTime) -- query event time unit

	-- iterate over
	for frames, atom in seq:foreach() do
		assert(frames == 0)
		assert(atom.body == 12)
	end

	-- indexing
	local atom = seq[1]
	assert(atom.body == 12)
end</code></pre>
			</div>

			<!-- Atom Tuple -->
			<div class="api-section">
			<h3 id="atom-tuple">Tuple</h3>
			<p>A Tuple atom, e.g. of type Atom.Tuple and variable size. Atom size
			denotes to number of items contained in atom body. An atom tuple
			consists of individual atom items.</p>

			<dl>
				<dt class="attr">tup.__len | #tup</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of items</dd>
			</dl>

			<dl>
				<dt class="attr">tup.__tostring | tostring(tup)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">tup.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="func">tup:unpack(from=1, to=#tup)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end position to unpack from, defaults to body size<dd>
				<dt class="ret">(userdata, ...)</dt>
					<dd>atom items unpacked from tuple</dd>
			</dl>

			<dl>
				<dt class="func">tup:foreach()</dt>
				<dt class="ret">(integer, userdata)</dt>
					<dd>iterates over all atom items returning index and atom item.</dd>
			</dl>

			<dl>
				<dt class="func">tup:__index(idx) | tup[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>item position to query for</dd>
				<dt class="ret">(userdata)</dt>
					<dd>atom item at position idx</dd>
			</dl>

			<pre><code data-ref="atom-tuple">-- Atom Tuple

-- serialize
function stash(forge)
	local tup = forge:tuple()
		tup:int(12)
	tup:pop()
end

function apply(tup)
	-- attributes
	assert(#tup == 1) -- query number of items
	print(tostring(tup)) -- convert to string
	assert(tup.type == Atom.Tuple) -- query type of atom

	-- iterate over
	for i, atom in tup:foreach() do
		assert(i == 1)
		assert(atom.body == 12)
	end

	-- unpack
	local a1 = tup:unpack()
	assert(a1.body == 12)

	-- indexing
	a1 = tup[1]
	assert(a1.body == 12)
end</code></pre>
			</div>

			<!-- Atom Object -->
			<div class="api-section">
			<h3 id="atom-object">Object</h3>
			<p>An Object atom, e.g. of type Atom.Object and variable size. Atom size
			denotes to number of properties contained in atom body. An atom object
			consists of individual properties.</p>

			<dl>
				<dt class="attr">obj.__len | #obj</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of properties</dd>
			</dl>

			<dl>
				<dt class="attr">obj.__tostring | tostring(obj)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">obj.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">obj.id</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom object ID</dd>
			</dl>

			<dl>
				<dt class="attr">obj.otype</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom object type</dd>
			</dl>

			<dl>
				<dt class="func">obj:foreach()</dt>
				<dt class="ret">(integer, userdata, integer)</dt>
					<dd>iterates over all properties returning property key, atom and context.</dd>
			</dl>

			<dl>
				<dt class="func">obj:__index(key) | obj[key]</dt>
				<dt>key (integer)</dt>
					<dd>URID of key to query for</dd>
				<dt class="ret">(userdata)</dt>
					<dd>property atom for key</dd>
			</dl>

			<pre><code data-ref="atom-object">-- Atom Object

local urn = HashMap('urn:moony:xyz#')

-- serialize
function stash(forge)
	local obj = forge:object(urn.otype, urn.id)
		obj:key(urn.key):int(12)
	obj:pop()
end

function apply(obj)
	-- attributes
	assert(#obj == 1) -- query number of properties
	print(tostring(obj)) -- convert to string
	assert(obj.type == Atom.Object) -- query type of atom
	assert(obj.id == urn.id) -- query id of object atom
	assert(obj.otype == urn.otype) -- query type of object atom

	-- iterate over
	for k, atom, ctx in obj:foreach() do
		assert(k == urn.key)
		assert(atom.body == 12)
		assert(ctx == 0)
	end

	-- indexing
	local atom = obj[urn.key]
	assert(atom.body == 12)
end</code></pre>
			</div>

			<!-- Atom Vector -->
			<div class="api-section">
			<h3 id="atom-vector">Vector</h3>
			<p>A Vector atom, e.g. of type Atom.Vector and variable size. Atom size
			denotes to number of items contained in atom body. An atom vector
			consists of equally typed atom items.</p>

			<dl>
				<dt class="attr">vec.__len | #vec</dt>
				<dt class="ret">(integer)</dt>
					<dd>number of items</dd>
			</dl>

			<dl>
				<dt class="attr">vec.__tostring | tostring(vec)</dt>
				<dt class="ret">(string)</dt>
					<dd>string representation of atom</dd>
			</dl>

			<dl>
				<dt class="attr">vec.type</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom type</dd>
			</dl>

			<dl>
				<dt class="attr">vec.childSize</dt>
				<dt class="ret">(integer)</dt>
					<dd>atom vector child size</dd>
			</dl>

			<dl>
				<dt class="attr">vec.childType</dt>
				<dt class="ret">(integer)</dt>
					<dd>URID of atom vector child type</dd>
			</dl>

			<dl>
				<dt class="func">vec:unpack(from=1, to=#vec)</dt>
				<dt>from (nil | integer)</dt>
					<dd>start position to unpack from, defaults to 1</dd>
				<dt>to (nil | integer)</dt>
					<dd>end position to unpack from, defaults to body size<dd>
				<dt class="ret">(userdata, ...)</dt>
					<dd>atom items unpacked from vector</dd>
			</dl>

			<dl>
				<dt class="func">vec:foreach()</dt>
				<dt class="ret">(integer, userdata)</dt>
					<dd>iterates over all vector items returning index and atom.</dd>
			</dl>

			<dl>
				<dt class="func">vec:__index(idx) | vec[idx]</dt>
				<dt>idx (integer)</dt>
					<dd>position to query for</dd>
				<dt class="ret">(userdata)</dt>
					<dd>atom of item at position idx</dd>
			</dl>

			<pre><code data-ref="atom-vector">-- Atom Vector

-- serialize
function stash(forge)
	forge:vector(Atom.Int):int(12):int(13):int(14):pop()
end

function apply(vec)
	-- attributes
	assert(#vec == 3) -- query number of items
	print(tostring(vec)) -- convert to string
	assert(vec.type == Atom.Vector) -- query type of atom
	assert(vec.childSize == 4) -- query child size of atom
	assert(vec.childType == Atom.Int) -- query child type of atom

	-- iterate over
	for i, atom in vec:foreach() do
		if i == 1 then
			assert(atom.body == 12)
		elseif i == 2 then
			assert(atom.body == 13)
		elseif i == 3 then
			assert(atom.body == 14)
		end
	end

	-- unpack
	local v1, v2, v3 = vec:unpack()
	assert(v1.body == 12)
	assert(v2.body == 13)
	assert(v3.body == 14)

	-- indexing
	v1, v2, v3 = vec[1], vec[2], vec[3]
	assert(v1.body == 12)
	assert(v2.body == 13)
	assert(v3.body == 14)
end</code></pre>
			</div>

	<!-- Stash -->
	<div class="api-section">
	<h1 id="stash">Stash</h1>
	<p>Sometimes it may be useful to not only be able to serialize atoms to forge
	objects provided to the user via one of the callback functions, but to be able
	to temporarily serialize some atoms to memory for later dispatch.</p>

	<p>For these usage scenarios there is the stash object, which according to
	its name, functions as temporary stash. It is a special object in the way
	that it can either be an atom object (with all its attributes and methods)
	or a forge object (with all its methods), depending on whether it is in its
	reading or writing mode.</p>

	<p>After creating a new stash, it is in its writing mode and thus can be used
	just like a forge object. After finishing the serialization procedure, the
	stash object may be switched into its reading mode and be used just like
	an atom object.</p>

		<dl>
			<dt class="func">stash:read()</dt>
			<dt class="ret">(userdata)</dt>
				<dd>reference to self as atom object to read from</dd>
		</dl>

		<dl>
			<dt class="func">stash:write()</dt>
			<dt class="ret">(userdata)</dt>
				<dd>reference to self as forge object to write to</dd>
		</dl>

		<pre><code data-ref="stash">-- Stash

-- a new stash defaults to writing mode - equivalent to forge object
local io = Stash()
io:int(12)

-- switch to reading mode - equivalent to atom object
io:read()
assert(io.body == 12)

-- switch to writing mode - automatically clears previous content
io:write()
io:int(13)

-- switch to reading mode
io:read()
assert(io.body == 13)</code></pre>
		</div>

	<!-- Options -->
	<div class="api-section">
	<h1 id="options">Options</h1>
	<p>Sometimes it is useful to know the sample rate (e.g. for timing) and size of
	sequence buffers and minimal and maximal to expect audio block frames.
	If the host exports those values, they may be queried via the options table.</p>

		<dl>
			<dt class="func">Options:__call(URID) | Options(URID) | Options:__index(URID) | Options[URID]</dt>
			<dt>URID (integer)</dt>
				<dd>key to index options table with as integer URID, e.g. valid keys are:
				Param.sampleRate, Buf_Size.sequenceSize, Buf_Size.minBlockLength, Buf_Size.maxBlockLength, Ui.updateRate</dd>
			<dt class="ret">(userdata)</dt>
				<dd>value of indexed key as atom object</dd>
		</dl>

		<dl>
			<dt class="func">Options:__pairs()</dt>
			<dt class="ret">(integer | userdata)</dt>
				<dd>iterates over all options, returning option key and atom userdata.</dd>
		</dl>

		<pre><code data-ref="options">-- Options


-- only available if exported by host
local sampleRate = Options[Param.sampleRate]
assert(sampleRate.body == 48000)
local sequenceSize = Options[Buf_Size.sequenceSize]
local minBlockLength = Options[Buf_Size.minBlockLength]
local maxBlockLength = Options[Buf_Size.maxBlockLength]
local updateRate = Options(Ui.updateRate)
	
for urid, atom in pairs(Options) do
	print(Unmap[urid], atom)
end</code></pre>
	</div>

	<!-- Responder -->
	<div class="api-section">
	<h1 id="responder">Responder</h1>
	<p>Responders are convenience wrappers to ease development of frequently used
	logic event handling schemes via callbacks.</p>

	<p>Moony offers simple responders for MIDI and OSC handling and more complex
	responders for time and state handling.</p>

	<p>By using responder objects, common problems like event filtering and
	sequencing can be written with much less and more understandable code.</p>

	<p>The StateResponder can be used to build simple user interfaces to make
	any moony script available to non-coders around the world.</p>

	</div>

		<!-- MIDIResponder -->
		<div class="api-section">
		<h2 id="responder-midi">MIDIResponder</h2>
		<p>Runs callbacks for received MIDI messages.</p>

		<dl>
			<dt class="func">MIDIResponder(responder, through=false)</dt>
			<dt>responder (table)</dt>
				<dd>table with responder callbacks</dd>
			<dt>through (boolean)</dt>
				<dd>flag whether to let unhandled messages through, defaults to false</dd>
			<dt class="ret">(userdata)</dt>
				<dd>MIDIResponder object</dd>
		</dl>

		<dl>
			<dt class="func">midiR:__call(frames, forge, atom) | midiR(frames, forge, atom)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of event</dd>
			<dt>forge (userdata)</dt>
				<dd>forge object</dd>
			<dt>atom (userdata)</dt>
				<dd>atom body of event</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether the event was handled, e.g. whether is was any MIDI at all</dd>
		</dl>

		<pre><code data-ref="responder-midi">-- MIDIResponder

-- define MIDI responder object with callbacks
local midiR = MIDIResponder({
	-- listen for NoteOn messages
	[MIDI.NoteOn] = function(self, frames, forge, chan, note, vel)
		assert(frames == 0)
		assert(chan == 0x1)
		assert(note == 69)
		assert(vel == 0x7f)

		-- send NoteOn message
		forge:time(frames):midi(MIDI.NoteOn | chan, note + 1, vel) -- increase note by 1
	end,
	-- listen for NoteOff messages
	[MIDI.NoteOff] = function(self, frames, forge, chan, note, vel)
		assert(frames == 1)
		assert(chan == 0x1)
		assert(note == 69)
		assert(vel == 0x0)

		-- send NoteOff message
		forge:time(frames):midi(MIDI.NoteOff | chan, note + 1, vel) -- increase note by 1
	end
}, false) -- block all MIDI messages not explicitly handled by responder

-- forge test messages
function stash_sequence(forge)
	forge:time(0):midi(MIDI.NoteOn | 0x1, 69, 0x7f)
	forge:time(1):midi(MIDI.NoteOff | 0x1, 69, 0x0)
	forge:time(2):midi(MIDI.Bender | 0x1, 0x0, 0x7f)
end

-- process test messages with responder
function apply_sequence(n, seq, forge)
	for frames, atom in seq:foreach() do
		local handled = midiR(frames, forge, atom)
		assert(handled == true)
	end
end

-- check responder output
function check(seq)
	assert(#seq == 2) -- only NoteOn and NoteOff have gone through
end</code></pre>
		</div>

		<!-- OSCResponder -->
		<div class="api-section">
		<h2 id="responder-osc">OSCResponder</h2>
		<p>Runs callbacks for received OSC messages.</p>

		<dl>
			<dt class="func">OSCResponder(responder)</dt>
			<dt>responder (table)</dt>
				<dd>table with responder callbacks</dd>
			<dt>through (boolean)</dt>
				<dd>flag whether to let unhandled messages through, defaults to false</dd>
			<dt class="ret">(userdata)</dt>
				<dd>OSCResponder object</dd>
		</dl>

		<dl>
			<dt class="func">oscR:__call(frames, forge, atom) | oscR(frames, forge, atom)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of event</dd>
			<dt>forge (userdata)</dt>
				<dd>forge object</dd>
			<dt>atom (userdata)</dt>
				<dd>atom body of event</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether the event was handled, e.g. whether is was any OSC at all</dd>
		</dl>

		<pre><code data-ref="responder-osc">-- OSCResponder

-- define OSC responder object with callbacks
local oscR = OSCResponder({
	-- listen for '/ping'
	['/ping'] = function(self, frames, forge, fmt, var1, var2)
		assert(frames == 0)
		assert(fmt == 'if')
		assert(var1 == 12)
		assert(var2 == 12.5)

		-- send a '/pong'
		forge:time(frames):message('/pong', fmt, var1, var2)
	end
}, true) -- route through not matched OSC messages

-- forge test messages
function stash_sequence(forge)
	forge:time(0):message('/ping', 'if', 12, 12.5)
end

-- process test messages with responder
function apply_sequence(n, seq, forge)
	for frames, atom in seq:foreach() do
		assert(frames == 0)
		assert(atom.otype == OSC.Message)
		assert(atom[OSC.messagePath].body == '/ping')

		local handled = oscR(frames, forge, atom)
		assert(handled == true)
	end
end

-- check responder output
function check(seq)
	for frames, atom in seq:foreach() do
		assert(frames == 0)
		assert(atom.otype == OSC.Message)
		assert(atom[OSC.messagePath].body == '/pong')
	end
end</code></pre>
		</div>

		<!-- TimeResponder -->
		<div class="api-section">
		<h2 id="responder-time">TimeResponder</h2>
		<p>Runs callbacks for received Time messages.</p>

		<dl>
			<dt class="func">TimeResponder(responder, multiplier=1.0)</dt>
			<dt>responder (table)</dt>
				<dd>table with responder callbacks</dd>
			<dt>multiplier (number)</dt>
				<dd>virtual multiplier to scale time signal with, defaults to 1.0</dd>
			<dt class="ret">(userdata)</dt>
				<dd>TimeResponder object</dd>
		</dl>

		<dl>
			<dt class="func">timeR:__call(from, to, forge, atom) | timeR(from, to, forge, atom)</dt>
			<dt>from (integer)</dt>
				<dd>frame time of last event or period beginning</dd>
			<dt>to (integer)</dt>
				<dd>frame time of current event or period ending</dd>
			<dt>forge (userdata)</dt>
				<dd>forge object</dd>
			<dt>atom (userdata)</dt>
				<dd>atom body of event</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether the event was handled, e.g. whether is was any Time event at all</dd>
		</dl>

		<dl>
			<dt class="func">timeR:__index(key) | timeR[key]</dt>
			<dt>key (integer)</dt>
				<dd>time position property key as integer URID, valid keys are: Time:speed, Time:bar, Time.barBeat, Time.beatUnit, Time.beatsPerBar, Time.beatsPerMinute, Time.frame, Time.framesPerSecond</dd>
			<dt class="ret">(integer | number)</dt>
				<dd>time position property value</dd>
		</dl>

		<dl>
			<dt class="func">timeR:stash(forge)</dt>
			<dt>forge (userdata)</dt>
				<dd>forge object to stash responder state to</dd>
			<dt class="ret">(userdata)</dt>
				<dd>self forge object</dd>
		</dl>

		<dl>
			<dt class="func">timeR:apply(atom)</dt>
			<dt>atom (userdata)</dt>
				<dd>atom object to apply responder state from</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether state has been applied successfully</dd>
		</dl>

		<dl>
			<dt class="attr">timeR.multiplier</dt>
			<dt class="ret">(number)</dt>
				<dd>virtual multiplier to scale time signal with</dd>
		</dl>

		<pre><code data-ref="responder-time">-- TimeResponder

-- define time responder object with callbacks
local timeR = TimeResponder({
	-- listen for speed change
	[Time.speed] = function(self, frames, forge, speed)
		assert( (speed == 0.0) or (speed == 1.0) )

		self.rolling = speed ~= 0.0
	end,
	-- listen for bar change
	[Time.bar] = function(self, frames, forge, bar)
		assert(bar == 0)
	end,
	-- listen for barBeat change
	[Time.barBeat] = function(self, frames, forge, barBeat)
		if forge then -- forge==nil in timeR:apply()
			assert(barBeat == 0.0)

			-- send NoteOn message at each whole beat
			if math.tointeger(barBeat) then
				forge:time(frames):midi(MIDI.NoteOn, 69, 0x7f)
			end
		end
	end,
	-- listen for beatUnit change
	[Time.beatUnit] = function(self, frames, forge, beatUnit)
		assert(beatUnit == 4)
	end,
	-- listen for beatsPerBar change
	[Time.beatsPerBar] = function(self, frames, forge, beatsPerBar)
		assert(beatsPerBar == 4.0)
	end,
	-- listen for beatsPerMinute change
	[Time.beatsPerMinute] = function(self, frames, forge, beatsPerMinute)
		assert(beatsPerMinute == 120.0)
	end,
	-- listen for frame change
	[Time.frame] = function(self, frames, forge, frame)
		assert(frame == 0)
	end,
	-- listen for framesPerSecond change
	[Time.framesPerSecond] = function(self, frames, forge, framesPerSecond)
		assert(framesPerSecond == 48000.0)
	end,
	rolling = false
}, 1.0)

-- index current transport state, can be called at any time
assert(timeR[Time.speed] == 0)
assert(timeR[Time.bar] == 0)
assert(timeR[Time.barBeat] == 0.0)
assert(timeR[Time.beatUnit] == 4)
assert(timeR[Time.beatsPerBar] == 4.0)
assert(timeR[Time.beatsPerMinute] == 120.0)
assert(timeR[Time.frame] == 0)
assert(timeR[Time.framesPerSecond] == 48000.0)
assert(timeR.multiplier == 1.0)

-- push current responder state to temporary stash
function stash(forge)
	assert(timeR:stash(forge) == forge)
end

-- pop and apply current responder state from temporary stash
function apply(atom)
	local handled = timeR:apply(atom)
	assert(handled == true)
end

-- forge test messages
function stash_sequence(forge)
	local obj = forge:time(0):object(Time.Position)
		obj:key(Time.speed):float(1.0) -- start transport
	obj:pop()
end

-- process test messages with responder
function apply_sequence(n, seq, forge)
	local from = 0 -- frame time of 'last event' aka 'period beginning'

	for to, atom in seq:foreach() do
		local handled = timeR(from, to, forge, atom)
		assert(handled == true)

		from = to -- update frame time of 'last event'
	end

	timeR(from, n, forge) -- we must call time responder until 'period ending'
end

-- check responder output
function check(seq)
	for frames, atom in seq:foreach() do
		assert(frames == 0)
		assert(atom.type == MIDI.MidiEvent)
		assert(atom.body == string.char(MIDI.NoteOn, 69, 0x7f))
	end
end</code></pre>
		</div>

		<!-- StateResponder -->
		<div class="api-section">
		<h2 id="responder-state">StateResponder</h2>
		<p>Runs callbacks for state handling via patch messages.</p>

		<dl>
			<dt class="func">StateResponder(responder)</dt>
			<dt>responder (table)</dt>
				<dd>table with responder callbacks</dd>
			<dt class="ret">(userdata)</dt>
				<dd>StateResponder object</dd>
		</dl>

		<dl>
			<dt class="func">stateR:__call(frames, forge, atom) | stateR(frames, forge, atom)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of current event</dd>
			<dt>forge (userdata)</dt>
				<dd>forge object</dd>
			<dt>atom (userdata)</dt>
				<dd>atom body of event</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether the event was handled, e.g. whether is was any patch event at all</dd>
		</dl>

		<dl>
			<dt class="func">stateR:register(frames, forge)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of current event, usually 0 aka start of period</dd>
			<dt>forge (userdata)</dt>
				<dd>forge object to register state to</dd>
			<dt class="ret">(userdata)</dt>
				<dd>self forge object</dd>
		</dl>

		<dl>
			<dt class="func">stateR:sync(frames, forge)</dt>
			<dt>frames (integer)</dt>
				<dd>frame time of current event</dd>
			<dt>forge (userdata)</dt>
				<dd>forge object to sync state to</dd>
			<dt class="ret">(userdata)</dt>
				<dd>self forge object</dd>
		</dl>

		<dl>
			<dt class="func">stateR:stash(forge)</dt>
			<dt>forge (userdata)</dt>
				<dd>forge object to stash responder state to</dd>
			<dt class="ret">(userdata)</dt>
				<dd>self forge object</dd>
		</dl>

		<dl>
			<dt class="func">stateR:apply(atom)</dt>
			<dt>atom (userdata)</dt>
				<dd>atom object to apply responder state from</dd>
			<dt class="ret">(boolean)</dt>
				<dd>flag whether state has been applied successfully</dd>
		</dl>

		<pre><code data-ref="responder-state">-- StateResponder

local urn = HashMap('urn:moony:xzy#')

-- define read-only parameter
local period = Parameter{
	[RDFS.label] = 'Period',
	[RDFS.comment] = 'set period',
	[RDFS.range] = Atom.Float,
	[LV2.minimum] = 1.0,
	[LV2.maximum] = 10.0,
	[Units.unit] = Units.s,
	[RDF.value] = 5.0
}

-- define read-write parameter
local frequency = Parameter{
	[RDFS.label] = 'Frequency',
	[RDFS.comment] = 'set frequency',
	[RDFS.range] = Atom.Int,
	[LV2.minimum] = 1,
	[LV2.maximum] = 48000,
	[Units.unit] = Units.hz,
	[RDF.value] = 44100
}

-- define state responder object with callbacks
local stateR = StateResponder({
	[Patch.readable] = {
		[urn.period] = period
	},
	[Patch.writable] = {
		[urn.frequency] = frequency
	}
})

-- push current responder state to temporary stash
function stash(forge)
	assert(stateR:stash(forge) == forge)
end

-- pop and apply current responder state from temporary stash
function apply(atom)
	local handled = stateR:apply(atom)
	assert(handled == true)
end

-- save current responder state to disk
function save(forge)
	assert(stateR:stash(forge) == forge)
end

-- restore current responder state from disk
function restore(atom)
	local handled = stateR:apply(atom)
	assert(handled == true)
end

-- register state upon code reload
function once(n, control, notify, seq, forge)
	assert(stateR:register(0, forge) == forge)
end

-- forge test messages
function stash_sequence(forge)
	forge:time(0):get(urn.period)
end

-- process test messages with responder
function apply_sequence(n, seq, forge)
	for frames, atom in seq:foreach() do
		assert(frames == 0)
		assert(atom.otype == Patch.Get)

		local handled = stateR(frames, forge, atom)
		assert(handled == true)
	end
end

-- check responder output
function check(seq)
	for frames, atom in seq:foreach() do
		assert(frames == 0)
		assert(atom.otype == Patch.Set)
		assert(atom[Patch.property].body == urn.period)
		assert(atom[Patch.value].body == 5.0)
	end
end</code></pre>
		</div>

		<!-- Parameter -->
		<div class="api-section">
		<h2 id="responder-parameter">Parameter</h2>
		<p>Adds convenience accessor metamethods to any parameter property table.</p>

		<dl>
			<dt class="func">Parameter(param)</dt>
			<dt>param (table)</dt>
				<dd>table with parameter properties</dd>
			<dt class="ret">(table)</dt>
				<dd>table with parameter properties plus metamethods</dd>
		</dl>

		<dl>
			<dt class="func">param:__call(value, frames=nil, forge=nil) | param(value, frames=nil, forge=nil)</dt>
			<dt>value (integer | number | string | boolean)</dt>
				<dd>new value to set parameter to</dd>
			<dt>frames (integer)</dt>
				<dd>frame time value is set on, defaults to nil</dd>
			<dt>forge (userdata)</dt>
				<dd>forge to send patch messages to, defaults to nil</dd>
		</dl>

		<dl>
			<dt class="func">param:__call() | param()</dt>
			<dt class="ret">(integer | number | string | boolean)</dt>
				<dd>current value parameter is set to</dd>
		</dl>

		<pre><code data-ref="responder-parameter">-- Parameter

local foo = Parameter({
	[RDFS.label] = 'Foo',
	[RDFS.range] = Atom.Float,
	[LV2.minimum] = 0.0,
	[LV2.maximum] = 1.0,
	[RDF.value] = 0.5
})

local bar = Parameter({
	[RDFS.label] = 'Bar',
	[RDFS.range] = Atom.Int,
	[LV2.minimum] = 0,
	[LV2.maximum] = 10,
	[RDF.value] = 5
})

function stash(forge)
	assert(foo() == 0.5)
	assert(foo[RDF.value] == 0.5)

	foo(0.8)
	assert(foo() == 0.8)

	foo[RDF.value] = 0.9
	assert(foo[RDF.value] == 0.9)

	--TODO
end</code></pre>
		</div>

	<!-- Utilities -->
	<div class="api-section">
	<h1 id="util">Utilities</h1>
	<p>Various hopefully useful utility functions.</p>
	</div>

		<!-- midi2cps -->
		<div class="api-section">
		<h2 id="util-midi2cps">midi2cps</h2>
		<p>Conversion from MIDI note to Hertz.</p>

		<dl>
			<dt class="func">midi2cps(note, base=69.0, noct=12.0, fref=440.0)</dt>
			<dt>note (number)</dt>
				<dd>MIDI note, fractions are allowed</dd>
			<dt>base (number)</dt>
				<dd>MIDI base note corresponding to reference frequency, defaults to 69.0 (A-5)</dd>
			<dt>noct (number)</dt>
				<dd>number of notes per octave, default to 12.0</dd>
			<dt>fref (number)</dt>
				<dd>reference frequency corresponding to MIDI base note, defaults to 440.0 Hz (A-5)</dd>
			<dt class="ret">(number)</dt>
				<dd>corresponding frequency in Hz</dd>
		</dl>

		<pre><code data-ref="util-midi2cps">-- midi2cps

assert(midi2cps(69.0) == 440.0) -- relative to 'A-5'==440 Hz
assert(midi2cps(60.0, 60, 12, 400) == 400.0) -- relative to 'C-5'==400 Hz</code></pre>
		</div>

		<!-- cps2midi -->
		<div class="api-section">
		<h2 id="util-cps2midi">cps2midi</h2>
		<p>Conversion from Hertz to MIDI note.</p>

		<dl>
			<dt class="func">cps2midi(cps, base=69.0, noct=12.0, fref=440.0)</dt>
			<dt>cps (number)</dt>
				<dd>frequency in Hz</dd>
			<dt>base (number)</dt>
				<dd>MIDI base note corresponding to reference frequency, defaults to 69.0 (A-5)</dd>
			<dt>noct (number)</dt>
				<dd>number of notes per octave, default to 12.0</dd>
			<dt>fref (number)</dt>
				<dd>reference frequency corresponding to MIDI base note, defaults to 440.0 Hz (A-5)</dd>
			<dt class="ret">(number)</dt>
				<dd>corresponding MIDI note</dd>
		</dl>

		<pre><code data-ref="util-cps2midi">-- cps2midi

assert(cps2midi(440.0) == 69.0) -- relative to 'A-5'==400 Hz
assert(cps2midi(400.0, 60, 12, 400) == 60.0) -- relative to 'C-5'==400 Hz</code></pre>
		</div>

		<!-- Note -->
		<div class="api-section">
		<h2 id="util-note">Note</h2>
		<p>Conversion from MIDI note number to note name and vice-versa.</p>

		<dl>
			<dt class="func">Note.__index(note) | Note[note]</dt>
			<dt>note (integer)</dt>
				<dd>MIDI Note number</dd>
			<dt class="ret">(string)</dt>
				<dd>MIDI note name</dd>
		</dl>

		<dl>
			<dt class="func">Note.__index(name) | Note[name]</dt>
			<dt>name (string)</dt>
				<dd>MIDI Note name</dd>
			<dt class="ret">(integer)</dt>
				<dd>MIDI note number</dd>
		</dl>

		<pre><code data-ref="util-note">-- Note

assert(Note[60] == 'C+4')
assert(Note['A+4'] == 69)</code></pre>
		</div>

		<!-- aes128 -->
		<div class="api-section">
		<h2 id="util-aes128">AES-128</h2>
		</div>

		<!-- aes128.encode -->
		<div class="api-section">
		<h3 id="util-aes128-encode">Encode</h3>
		<p>AES-128 encryption of byte strings.</p>

		<dl>
			<dt class="func">aes128.encode(value, pass)</dt>
			<dt>value (string)</dt>
				<dd>clear text byte string to encode</dd>
			<dt>pass (string)</dt>
				<dd>128-bit passphrase, either as raw byte string or as hex-encoded string</dd>
			<dt class="ret">(string, integer)</dt>
				<dd>corresponding secret byte string, length of encoded clear text</dd>
		</dl>

		<pre><code data-ref="util-aes128.encode">-- encrypt

local pass = '2b7e151628aed2a6abf7158809cf4f3c'
local value = 'hello world'

local secret, len = aes128.encode(value, pass)
assert(aes128.decode(secret, pass, len) == value)</code></pre>
		</div>

		<!-- aes128.decode -->
		<div class="api-section">
		<h3 id="util-aes128-decode">Decode</h3>
		<p>AES-128 decryption of byte strings.</p>

		<dl>
			<dt class="func">aes128.decode(value, pass)</dt>
			<dt>value (string)</dt>
				<dd>secret byte string to decode </dd>
			<dt>pass (string)</dt>
				<dd>128-bit passphrase, either as raw byte string or as hex-encoded string</dd>
			<dt>len (integer)</dt>
				<dd>length of encoded clear text</dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding clear text byte string</dd>
		</dl>

		<pre><code data-ref="util-aes128-decode">-- decrypt

local pass = string.char(
	0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
	0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c)
local value = 'hello world'

local secret, len = aes128.encode(value, pass)
assert(aes128.decode(secret, pass, len) == value)</code></pre>
	</div>

		<!-- base64 -->
		<div class="api-section">
		<h2 id="util-base64">Base64</h2>
		</div>

		<!-- base64.encode -->
		<div class="api-section">
		<h3 id="util-base64-encode">Encode</h3>
		<p>Base64 encoding of byte strings.</p>

		<dl>
			<dt class="func">base64.encode(value)</dt>
			<dt>value (string)</dt>
				<dd>clear text byte string to encode</dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding encoded string</dd>
		</dl>

		<pre><code data-ref="util-base64.encode">-- encode

local value = 'hello world'

local encoded = base64.encode(value)</code></pre>
		</div>

		<!-- base64.decode -->
		<div class="api-section">
		<h3 id="util-base64-decode">Decode</h3>
		<p>Base64 decoding of byte strings.</p>

		<dl>
			<dt class="func">base64.decode(value)</dt>
			<dt>value (string)</dt>
				<dd>encoded string to decode </dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding clear text byte string</dd>
		</dl>

		<pre><code data-ref="util-base64-decode">-- decode

local value = 'hello world'

local encoded = base64.encode(value)
assert(base64.decode(encoded) == value)</code></pre>
	</div>

		<!-- ascii85 -->
		<div class="api-section">
		<h2 id="util-ascii85">Ascii85</h2>
		</div>

		<!-- ascii85.encode -->
		<div class="api-section">
		<h3 id="util-ascii85-encode">Encode</h3>
		<p>Ascii85 encoding of byte strings.</p>

		<dl>
			<dt class="func">ascii85.encode(value)</dt>
			<dt>value (string)</dt>
				<dd>clear text byte string to encode</dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding encoded string</dd>
		</dl>

		<pre><code data-ref="util-ascii85.encode">-- encode

local value = 'hello world'

local encoded = ascii85.encode(value)</code></pre>
		</div>

		<!-- ascii85.decode -->
		<div class="api-section">
		<h3 id="util-ascii85-decode">Decode</h3>
		<p>Ascii85 decoding of byte strings.</p>

		<dl>
			<dt class="func">ascii85.decode(value)</dt>
			<dt>value (string)</dt>
				<dd>encoded string to decode </dd>
			<dt class="ret">(string)</dt>
				<dd>corresponding clear text byte string</dd>
		</dl>

		<pre><code data-ref="util-ascii85-decode">-- decode

local value = 'hello world'

local encoded = ascii85.encode(value)
assert(ascii85.decode(encoded) == value)</code></pre>
	</div>

	<!-- Constants -->
	<div class="api-section">
	<h1 id="constants">Constants</h1>
	<p>Frequently used URID values and all MIDI message and controller constants
	are premapped and conveniently accessible in their own tables.</p>

		<dl>
			<dt class="func">(table):__index(key) | (table)[key]</dt>
			<dt>key (string)</dt>
				<dd>key to index constants table with</dd>
			<dt class="ret">(integer)</dt>
				<dd>corresponding URID or integer for given key</dd>
		</dl>

		<pre><code data-ref="constants">-- Constants

local ctx = {
	lv2   = HashMap('http://lv2plug.in/ns/lv2core#'),
	param = HashMap('http://lv2plug.in/ns/ext/parameters#'),
	atom  = HashMap('http://lv2plug.in/ns/ext/atom#'),
	time  = HashMap('http://lv2plug.in/ns/ext/time#'),
	midi  = HashMap('http://lv2plug.in/ns/ext/midi#'),
	bufsz = HashMap('http://lv2plug.in/ns/ext/buf-size#'),
	patch = HashMap('http://lv2plug.in/ns/ext/patch#'),
	units = HashMap('http://lv2plug.in/ns/extensions/units#'),
	osc   = HashMap('http://open-music-kontrollers.ch/lv2/osc#'),
	rdf   = HashMap('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
	rdfs  = HashMap('http://www.w3.org/2000/01/rdf-schema#'),
	moony = HashMap('http://open-music-kontrollers.ch/lv2/moony#'),
	lua   = HashMap('http://lua.org#'),
}

-- Atom URID constants
assert(Atom.Bool == ctx.atom.Bool)
assert(Atom.Int == ctx.atom.Int)
assert(Atom.Long == ctx.atom.Long)
assert(Atom.Float == ctx.atom.Float)
assert(Atom.Double == ctx.atom.Double)
assert(Atom.URID == ctx.atom.URID)
assert(Atom.URI == ctx.atom.URI)
assert(Atom.String == ctx.atom.String)
assert(Atom.Literal == ctx.atom.Literal)
assert(Atom.Path == ctx.atom.Path)
assert(Atom.Chunk == ctx.atom.Chunk)
assert(Atom.Property == ctx.atom.Property)
assert(Atom.Object == ctx.atom.Object)
assert(Atom.Sequence == ctx.atom.Sequence)
assert(Atom.Tuple == ctx.atom.Tuple)
assert(Atom.Vector == ctx.atom.Vector)
assert(Atom.beatTime == ctx.atom.beatTime)
assert(Atom.frameTime == ctx.atom.frameTime)
assert(Atom.childType == ctx.atom.childType)

-- Time URID constants
assert(Time.Position == ctx.time.Position)
assert(Time.barBeat == ctx.time.barBeat)
assert(Time.bar == ctx.time.bar)
assert(Time.beat == ctx.time.beat)
assert(Time.beatUnit == ctx.time.beatUnit)
assert(Time.beatsPerBar == ctx.time.beatsPerBar)
assert(Time.beatsPerMinute == ctx.time.beatsPerMinute)
assert(Time.frame == ctx.time.frame)
assert(Time.framesPerSecond == ctx.time.framesPerSecond)
assert(Time.speed == ctx.time.speed)

-- MIDI URID constants
assert(MIDI.MidiEvent == ctx.midi.MidiEvent)

-- MIDI message and controller constants
for k, v in pairs(MIDI) do
	if k ~= MIDI.MidiEvent then
		print(k, v)
	end
end

-- OSC URID constants
assert(OSC.Event == ctx.osc.Event)
assert(OSC.Packet == ctx.osc.Packet)
assert(OSC.Bundle == ctx.osc.Bundle)
assert(OSC.bundleTimetag == ctx.osc.bundleTimetag)
assert(OSC.bundleItems == ctx.osc.bundleItems)
assert(OSC.Message == ctx.osc.Message)
assert(OSC.messagePath == ctx.osc.messagePath)
assert(OSC.messageArguments == ctx.osc.messageArguments)
assert(OSC.Timetag == ctx.osc.Timetag)
assert(OSC.timetagIntegral == ctx.osc.timetagIntegral)
assert(OSC.timetagFraction == ctx.osc.timetagFraction)
assert(OSC.Nil == ctx.osc.Nil)
assert(OSC.Impulse == ctx.osc.Impulse)
assert(OSC.Char == ctx.osc.Char)
assert(OSC.RGBA == ctx.osc.RGBA)

-- LV2 Param URID constants
assert(Param.sampleRate == ctx.param.sampleRate)

-- LV2 LV2 URID constants
assert(LV2.minimum == ctx.lv2.minimum)
assert(LV2.maximum == ctx.lv2.maximum)
assert(LV2.scalePoint == ctx.lv2.scalePoint)

-- Buffer size URID constants
assert(Buf_Size.minBlockLength == ctx.bufsz.minBlockLength)
assert(Buf_Size.maxBlockLength == ctx.bufsz.maxBlockLength)
assert(Buf_Size.sequenceSize == ctx.bufsz.sequenceSize)

-- Patch URID constants
assert(Patch.Ack == ctx.patch.Ack)
assert(Patch.Delete == ctx.patch.Delete)
assert(Patch.Copy == ctx.patch.Copy)
assert(Patch.Error == ctx.patch.Error)
assert(Patch.Get == ctx.patch.Get)
assert(Patch.Message == ctx.patch.Message)
assert(Patch.Move == ctx.patch.Move)
assert(Patch.Patch == ctx.patch.Patch)
assert(Patch.Post == ctx.patch.Post)
assert(Patch.Put == ctx.patch.Put)
assert(Patch.Request == ctx.patch.Request)
assert(Patch.Response == ctx.patch.Response)
assert(Patch.Set == ctx.patch.Set)
assert(Patch.add == ctx.patch.add)
assert(Patch.body == ctx.patch.body)
assert(Patch.destination == ctx.patch.destination)
assert(Patch.property == ctx.patch.property)
assert(Patch.readable == ctx.patch.readable)
assert(Patch.remove == ctx.patch.remove)
assert(Patch.request == ctx.patch.request)
assert(Patch.subject == ctx.patch.subject)
assert(Patch.sequenceNumber == ctx.patch.sequenceNumber)
assert(Patch.value == ctx.patch.value)
assert(Patch.wildcard == ctx.patch.wildcard)
assert(Patch.writable == ctx.patch.writable)

-- RDF URID constants
assert(RDF.value == ctx.rdf.value)
assert(RDF.type == ctx.rdf.type)

-- RDFS URID constants
assert(RDFS.label == ctx.rdfs.label)
assert(RDFS.range == ctx.rdfs.range)
assert(RDFS.comment == ctx.rdfs.comment)

-- Units URID constants
assert(Units.Conversion == ctx.units.Conversion)
assert(Units.Unit == ctx.units.Unit)
assert(Units.bar == ctx.units.bar)
assert(Units.beat == ctx.units.beat)
assert(Units.bpm == ctx.units.bpm)
assert(Units.cent == ctx.units.cent)
assert(Units.cm == ctx.units.cm)
assert(Units.coef == ctx.units.coef)
assert(Units.conversion == ctx.units.conversion)
assert(Units.db == ctx.units.db)
assert(Units.degree == ctx.units.degree)
assert(Units.frame == ctx.units.frame)
assert(Units.hz == ctx.units.hz)
assert(Units.inch == ctx.units.inch)
assert(Units.khz == ctx.units.khz)
assert(Units.km == ctx.units.km)
assert(Units.m == ctx.units.m)
assert(Units.mhz == ctx.units.mhz)
assert(Units.midiNote == ctx.units.midiNote)
assert(Units.midiController == ctx.units.midiController)
assert(Units.mile == ctx.units.mile)
assert(Units.min == ctx.units.min)
assert(Units.mm == ctx.units.mm)
assert(Units.ms == ctx.units.ms)
assert(Units.name == ctx.units.name)
assert(Units.oct == ctx.units.oct)
assert(Units.pc == ctx.units.pc)
assert(Units.prefixConversion == ctx.units.prefixConversion)
assert(Units.render == ctx.units.render)
assert(Units.s == ctx.units.s)
assert(Units.semitone12TET == ctx.units.semitone12TET)
assert(Units.symbol == ctx.units.symbol)
assert(Units.unit == ctx.units.unit)

-- Moony URID constants
assert(Moony.color == ctx.moony.color)
assert(Moony.syntax == ctx.moony.syntax)

-- Lua URID constants
assert(Lua.lang == ctx.lua.lang)</code></pre>
	</div>

	<div class="api-section">
	<h1 id="license">License</h1>
		<p>Copyright &copy; 2015-2016 Hanspeter Portner
		(<a href="mailto:dev@open-music-kontrollers.ch">dev@open-music-kontrollers.ch</a>)</p>

		<p>This is free software: you can redistribute it and/or modify
		it under the terms of the Artistic License 2.0 as published by
		The Perl Foundation.</p>

		<p>This source is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
		Artistic License 2.0 for more details.</p>

		<p>You should have received a copy of the Artistic License 2.0
		along the source as a COPYING file. If not, obtain it from
		<a href="http://www.perlfoundation.org/artistic_license_2_0"> http://www.perlfoundation.org/artistic_license_2_0</a>.</p>
	</div>

</div>

</html>
